{"version":3,"sources":["webpack:///./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack:///./node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js","webpack:///./node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"],"names":["targetMap","WeakMap","effectStack","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","isEffect","fn","_isEffect","effect","options","raw","createReactiveEffect","lazy","stop","active","cleanup","onStop","uid","scheduler","undefined","includes","enableTracking","push","pop","resetTracking","length","id","allowRecurse","deps","i","delete","shouldTrack","trackStack","pauseTracking","last","track","target","type","key","depsMap","get","set","Map","dep","Set","has","add","trigger","newValue","oldValue","oldTarget","effects","effectsToAdd","forEach","run","isNonTrackableKeys","builtInSymbols","Object","getOwnPropertyNames","map","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","res","isRef","shouldUnwrap","value","readonly","reactive","method","Array","prototype","args","arr","toRaw","this","l","apply","createSetter","shallowSet","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","call","has$1","size","proto","set$1","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","done","next","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","markRaw","convert","val","r","Boolean","__v_isRef","ref","createRef","shallowRef","RefImpl","_rawValue","_shallow","_value","newVal","rawValue","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","toRef","ObjectRefImpl","_object","_key","ComputedRefImpl","getter","_setter","_dirty","self","computed","getterOrOptions","setter","defaultOnError","error","createCompilerError","code","loc","messages","additionalMessage","msg","SyntaxError","String","FRAGMENT","TELEPORT","SUSPENSE","KEEP_ALIVE","BASE_TRANSITION","OPEN_BLOCK","CREATE_BLOCK","CREATE_VNODE","CREATE_COMMENT","CREATE_TEXT","CREATE_STATIC","RESOLVE_COMPONENT","RESOLVE_DYNAMIC_COMPONENT","RESOLVE_DIRECTIVE","WITH_DIRECTIVES","RENDER_LIST","RENDER_SLOT","CREATE_SLOTS","TO_DISPLAY_STRING","MERGE_PROPS","TO_HANDLERS","CAMELIZE","CAPITALIZE","TO_HANDLER_KEY","SET_BLOCK_TRACKING","PUSH_SCOPE_ID","POP_SCOPE_ID","WITH_SCOPE_ID","WITH_CTX","UNREF","IS_REF","helperNameMap","registerRuntimeHelpers","helpers","getOwnPropertySymbols","s","locStub","source","start","line","column","offset","end","createRoot","children","components","directives","hoists","imports","cached","temps","codegenNode","createVNodeCall","context","tag","props","patchFlag","dynamicProps","isBlock","disableTracking","helper","createArrayExpression","elements","createObjectExpression","properties","createObjectProperty","createSimpleExpression","content","isStatic","constType","createCompoundExpression","createCallExpression","callee","arguments","createFunctionExpression","params","returns","newline","isSlot","createConditionalExpression","test","consequent","alternate","createCacheExpression","index","isVNode","isStaticExp","p","isBuiltInType","expected","isCoreComponent","nonIdentifierRE","isSimpleIdentifier","name","memberExpRE","isMemberExpression","path","trim","getInnerRange","substr","newLoc","advancePositionWithClone","pos","numberOfCharacters","advancePositionWithMutation","linesCount","lastNewLinePos","charCodeAt","findDir","node","allowEmpty","exp","findProp","dynamicOnly","isBindKey","arg","hasDynamicKeyVBind","some","isText","isVSlot","isTemplateNode","tagType","isSlotOutlet","injectProp","prop","propsWithInjection","first","unshift","alreadyExists","propKeyName","toValidAssetId","replace","decodeRE","decodeMap","gt","lt","amp","apos","quot","defaultParserOptions","delimiters","getNamespace","getTextMode","isVoidTag","isPreTag","isCustomElement","decodeEntities","rawText","_","p1","onError","comments","baseParse","createParserContext","getCursor","parseChildren","getSelection","rawOptions","originalSource","inPre","inVPre","mode","ancestors","parent","ns","nodes","isEnd","startsWith","parseInterpolation","emitError","parseComment","parseBogusComment","parseCDATA","advanceBy","parseTag","parseElement","parseText","pushNode","removedWhitespace","prev","match","exec","slice","prevIndex","nestedIndex","indexOf","contentStart","closeIndex","wasInPre","wasInVPre","element","isPreBoundary","isVPreBoundary","isSelfClosing","startsWithEndTagOpen","toLowerCase","isSpecialTemplateDirective","advanceSpaces","cursor","currentSource","parseAttributes","hasVIs","isNativeTag","isBuiltInComponent","attributeNames","attr","parseAttribute","nameSet","pattern","m","parseAttributeValue","dirName","startOffset","lastIndexOf","getNewPosition","endsWith","isQuoted","valueLoc","modifiers","split","quote","endIndex","parseTextData","unexpectedChars","open","close","innerStart","innerEnd","rawContentLength","rawContent","preTrimContent","endOffset","endTokens","xs","searchString","root","walk","isSingleElementRoot","child","doNotHoistNode","hasHoistedNode","canStringify","constantType","getConstantType","hoist","flag","getPatchFlag","getGeneratedPropsConstantType","getNodeProps","contentType","isComponent","scopes","vSlot","branches","transformHoist","constantCache","returnType","generatedPropsType","childType","expType","removeHelper","keyType","valueType","parseInt","createTransformContext","filename","prefixIdentifiers","hoistStatic","cacheHandlers","nodeTransforms","directiveTransforms","expressionPlugins","scopeId","slotted","ssr","ssrCssVars","bindingMetadata","inline","isTS","nameMatch","selfName","identifiers","create","vFor","vPre","vOnce","currentNode","childIndex","count","currentCount","list","removalIndex","onNodeRemoved","splice","identifier","hoisted","transform","traverseNode","createRootCodegen","keys","traverseChildren","nodeRemoved","exitFns","onExit","createStructuralDirectiveTransform","matches","n","PURE_ANNOTATION","createCodegenContext","ast","sourceMap","optimizeImports","runtimeGlobalName","runtimeModuleName","indentLevel","pure","withoutNewLine","repeat","generate","onContextCreated","indent","deindent","hasHelpers","useWithBlock","preambleContext","genFunctionPreamble","functionName","signature","join","genAssets","genNode","preamble","toJSON","VueBinding","aliasHelper","staticHelpers","genHoists","assets","resolver","maybeSelfReference","JSON","stringify","genNodeListAsArray","multilines","genNodeList","comma","genText","genExpression","genInterpolation","genCompoundExpression","genComment","genVNodeCall","genCallExpression","genObjectExpression","genArrayExpression","genFunctionExpression","genConditionalExpression","genCacheExpression","genExpressionAsPropertyKey","text","genNullableArgs","body","needNewline","needsParens","isNested","RegExp","transformIf","dir","processIf","ifNode","branch","isRoot","siblings","sibling","createCodegenNodeForBranch","parentCondition","getParentCondition","processCodegen","createIfBranch","replaceNode","removeNode","condition","userKey","keyIndex","createChildrenCodegenNode","keyProperty","firstChild","needFragmentWrapper","vnodeCall","transformFor","processFor","forNode","renderExp","keyProp","isStableFragment","fragmentFlag","childBlock","isTemplate","slotOutlet","createForLoopParams","parseResult","parseForExpression","addIdentifiers","removeIdentifiers","valueAlias","keyAlias","objectIndexAlias","forAliasRE","forIteratorRE","stripParensRE","input","inMatch","LHS","RHS","createAliasExpression","valueContent","trimmedOffset","iteratorMatch","keyContent","keyOffset","indexContent","range","defaultFallback","trackSlotScopes","buildClientSlotFn","buildSlots","buildSlotFn","slotsProperties","dynamicSlots","buildDefaultSlotProperty","hasDynamicSlots","onComponentSlot","hasTemplateSlots","hasNamedDefaultSlot","implicitDefaultChildren","seenSlotNames","slotElement","slotDir","slotChildren","slotLoc","slotName","slotProps","dirLoc","staticSlotName","slotFunction","vIf","vElse","buildDynamicSlot","j","conditional","slotFlag","hasForwardedSlots","slots","concat","directiveImportMap","transformElement","vnodeTag","resolveComponentType","isDynamicComponent","vnodeProps","vnodeChildren","vnodePatchFlag","vnodeDynamicProps","dynamicPropNames","vnodeDirectives","shouldUseBlock","propsBuildResult","buildProps","buildDirectiveArgs","shouldBuildAsSlots","hasDynamicTextChild","stringifyDynamicPropNames","isProp","isComponentTag","builtIn","elementLoc","mergeArgs","runtimeDirectives","hasRef","hasClassBinding","hasStyleBinding","hasHydrationEventBinding","hasDynamicKeys","hasVnodeHook","analyzePatchFlag","isEventHandler","isBind","isOn","dedupeProperties","directiveTransform","needRuntime","propsExpression","knownProps","deduped","existing","mergeAsArray","incoming","dirArgs","runtime","helperString","trueExpression","modifier","propsNamesString","cacheStringFunction","cache","str","hit","camelizeRE","camelize","c","toUpperCase","transformSlotOutlet","processSlotOutlet","slotArgs","nonNameProps","fnExpRE","transformOn","augmentor","eventName","rawName","shouldCache","isMemberExp","isInlineStatement","hasMultipleStatements","transformBind","transformText","currentContainer","hasText","callArgs","seen","WeakSet","transformOnce","cur","transformModel","createTransformProps","rawExp","expString","maybeRef","propName","assignmentExp","eventArg","modifiersKey","getBaseTransformPreset","on","bind","model","baseCompile","template","isModuleMode","noopDirectiveTransform","V_MODEL_RADIO","V_MODEL_CHECKBOX","V_MODEL_TEXT","V_MODEL_SELECT","V_MODEL_DYNAMIC","V_ON_WITH_MODIFIERS","V_ON_WITH_KEYS","V_SHOW","TRANSITION","TRANSITION_GROUP","decoder","decodeHtmlBrowser","document","createElement","innerHTML","textContent","isRawTextContainer","parserOptions","a","transformStyle","parseInlineCSS","cssText","normalized","createDOMCompilerError","transformVHtml","transformVText","baseResult","directiveToUse","isInvalidType","isEventOptionModifier","isNonKeyModifier","maybeKeyModifier","isKeyboardEvent","resolveModifiers","keyModifiers","nonKeyModifiers","eventOptionModifiers","transformClick","event","isStaticClick","handlerExp","modifierPostfix","transformShow","ignoreSideEffectTags","DOMNodeTransforms","DOMDirectiveTransforms","cloak","html","show","compile"],"mappings":"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","file":"js/chunk-vendors~4e98e87e.999b2e31.js","sourcesContent":["import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst shallowReadonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, true)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        if (self._dirty) {\r\n            self._value = this.effect();\r\n            self._dirty = false;\r\n        }\r\n        track(self, \"get\" /* GET */, 'value');\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","import { isString, hyphenate, extend, isObject, isArray, NO, makeMap, isSymbol, NOOP, EMPTY_OBJ, capitalize, camelize as camelize$1, PatchFlagNames, slotFlagsText, isOn, isReservedProp, toHandlerKey } from '@vue/shared';\nexport { generateCodeFrame } from '@vue/shared';\n\nfunction defaultOnError(error) {\r\n    throw error;\r\n}\r\nfunction createCompilerError(code, loc, messages, additionalMessage) {\r\n    const msg = (process.env.NODE_ENV !== 'production') || !true\r\n        ? (messages || errorMessages)[code] + (additionalMessage || ``)\r\n        : code;\r\n    const error = new SyntaxError(String(msg));\r\n    error.code = code;\r\n    error.loc = loc;\r\n    return error;\r\n}\r\nconst errorMessages = {\r\n    // parse errors\r\n    [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',\r\n    [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',\r\n    [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',\r\n    [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',\r\n    [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: \"Illegal '/' in tags.\",\r\n    [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',\r\n    [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',\r\n    [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',\r\n    [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',\r\n    [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',\r\n    [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',\r\n    [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',\r\n    [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: \"Illegal tag name. Use '&lt;' to print '<'.\",\r\n    [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',\r\n    [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',\r\n    [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',\r\n    [16 /* NESTED_COMMENT */]: \"Unexpected '<!--' in comment.\",\r\n    [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\r\n    [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\r\n    [19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */]: \"Attribute name cannot start with '='.\",\r\n    [21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */]: \"'<?' is allowed only in XML context.\",\r\n    [22 /* UNEXPECTED_SOLIDUS_IN_TAG */]: \"Illegal '/' in tags.\",\r\n    // Vue-specific parse errors\r\n    [23 /* X_INVALID_END_TAG */]: 'Invalid end tag.',\r\n    [24 /* X_MISSING_END_TAG */]: 'Element is missing end tag.',\r\n    [25 /* X_MISSING_INTERPOLATION_END */]: 'Interpolation end sign was not found.',\r\n    [26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */]: 'End bracket for dynamic directive argument was not found. ' +\r\n        'Note that dynamic directive argument cannot contain spaces.',\r\n    // transform errors\r\n    [27 /* X_V_IF_NO_EXPRESSION */]: `v-if/v-else-if is missing expression.`,\r\n    [28 /* X_V_IF_SAME_KEY */]: `v-if/else branches must use unique keys.`,\r\n    [29 /* X_V_ELSE_NO_ADJACENT_IF */]: `v-else/v-else-if has no adjacent v-if.`,\r\n    [30 /* X_V_FOR_NO_EXPRESSION */]: `v-for is missing expression.`,\r\n    [31 /* X_V_FOR_MALFORMED_EXPRESSION */]: `v-for has invalid expression.`,\r\n    [32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */]: `<template v-for> key should be placed on the <template> tag.`,\r\n    [33 /* X_V_BIND_NO_EXPRESSION */]: `v-bind is missing expression.`,\r\n    [34 /* X_V_ON_NO_EXPRESSION */]: `v-on is missing expression.`,\r\n    [35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */]: `Unexpected custom directive on <slot> outlet.`,\r\n    [36 /* X_V_SLOT_MIXED_SLOT_USAGE */]: `Mixed v-slot usage on both the component and nested <template>.` +\r\n        `When there are multiple named slots, all slots should use <template> ` +\r\n        `syntax to avoid scope ambiguity.`,\r\n    [37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */]: `Duplicate slot names found. `,\r\n    [38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */]: `Extraneous children found when component already has explicitly named ` +\r\n        `default slot. These children will be ignored.`,\r\n    [39 /* X_V_SLOT_MISPLACED */]: `v-slot can only be used on components or <template> tags.`,\r\n    [40 /* X_V_MODEL_NO_EXPRESSION */]: `v-model is missing expression.`,\r\n    [41 /* X_V_MODEL_MALFORMED_EXPRESSION */]: `v-model value must be a valid JavaScript member expression.`,\r\n    [42 /* X_V_MODEL_ON_SCOPE_VARIABLE */]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\r\n    [43 /* X_INVALID_EXPRESSION */]: `Error parsing JavaScript expression: `,\r\n    [44 /* X_KEEP_ALIVE_INVALID_CHILDREN */]: `<KeepAlive> expects exactly one child component.`,\r\n    // generic errors\r\n    [45 /* X_PREFIX_ID_NOT_SUPPORTED */]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\r\n    [46 /* X_MODULE_MODE_NOT_SUPPORTED */]: `ES module mode is not supported in this build of compiler.`,\r\n    [47 /* X_CACHE_HANDLER_NOT_SUPPORTED */]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\r\n    [48 /* X_SCOPE_ID_NOT_SUPPORTED */]: `\"scopeId\" option is only supported in module mode.`\r\n};\n\nconst FRAGMENT = Symbol((process.env.NODE_ENV !== 'production') ? `Fragment` : ``);\r\nconst TELEPORT = Symbol((process.env.NODE_ENV !== 'production') ? `Teleport` : ``);\r\nconst SUSPENSE = Symbol((process.env.NODE_ENV !== 'production') ? `Suspense` : ``);\r\nconst KEEP_ALIVE = Symbol((process.env.NODE_ENV !== 'production') ? `KeepAlive` : ``);\r\nconst BASE_TRANSITION = Symbol((process.env.NODE_ENV !== 'production') ? `BaseTransition` : ``);\r\nconst OPEN_BLOCK = Symbol((process.env.NODE_ENV !== 'production') ? `openBlock` : ``);\r\nconst CREATE_BLOCK = Symbol((process.env.NODE_ENV !== 'production') ? `createBlock` : ``);\r\nconst CREATE_VNODE = Symbol((process.env.NODE_ENV !== 'production') ? `createVNode` : ``);\r\nconst CREATE_COMMENT = Symbol((process.env.NODE_ENV !== 'production') ? `createCommentVNode` : ``);\r\nconst CREATE_TEXT = Symbol((process.env.NODE_ENV !== 'production') ? `createTextVNode` : ``);\r\nconst CREATE_STATIC = Symbol((process.env.NODE_ENV !== 'production') ? `createStaticVNode` : ``);\r\nconst RESOLVE_COMPONENT = Symbol((process.env.NODE_ENV !== 'production') ? `resolveComponent` : ``);\r\nconst RESOLVE_DYNAMIC_COMPONENT = Symbol((process.env.NODE_ENV !== 'production') ? `resolveDynamicComponent` : ``);\r\nconst RESOLVE_DIRECTIVE = Symbol((process.env.NODE_ENV !== 'production') ? `resolveDirective` : ``);\r\nconst WITH_DIRECTIVES = Symbol((process.env.NODE_ENV !== 'production') ? `withDirectives` : ``);\r\nconst RENDER_LIST = Symbol((process.env.NODE_ENV !== 'production') ? `renderList` : ``);\r\nconst RENDER_SLOT = Symbol((process.env.NODE_ENV !== 'production') ? `renderSlot` : ``);\r\nconst CREATE_SLOTS = Symbol((process.env.NODE_ENV !== 'production') ? `createSlots` : ``);\r\nconst TO_DISPLAY_STRING = Symbol((process.env.NODE_ENV !== 'production') ? `toDisplayString` : ``);\r\nconst MERGE_PROPS = Symbol((process.env.NODE_ENV !== 'production') ? `mergeProps` : ``);\r\nconst TO_HANDLERS = Symbol((process.env.NODE_ENV !== 'production') ? `toHandlers` : ``);\r\nconst CAMELIZE = Symbol((process.env.NODE_ENV !== 'production') ? `camelize` : ``);\r\nconst CAPITALIZE = Symbol((process.env.NODE_ENV !== 'production') ? `capitalize` : ``);\r\nconst TO_HANDLER_KEY = Symbol((process.env.NODE_ENV !== 'production') ? `toHandlerKey` : ``);\r\nconst SET_BLOCK_TRACKING = Symbol((process.env.NODE_ENV !== 'production') ? `setBlockTracking` : ``);\r\nconst PUSH_SCOPE_ID = Symbol((process.env.NODE_ENV !== 'production') ? `pushScopeId` : ``);\r\nconst POP_SCOPE_ID = Symbol((process.env.NODE_ENV !== 'production') ? `popScopeId` : ``);\r\nconst WITH_SCOPE_ID = Symbol((process.env.NODE_ENV !== 'production') ? `withScopeId` : ``);\r\nconst WITH_CTX = Symbol((process.env.NODE_ENV !== 'production') ? `withCtx` : ``);\r\nconst UNREF = Symbol((process.env.NODE_ENV !== 'production') ? `unref` : ``);\r\nconst IS_REF = Symbol((process.env.NODE_ENV !== 'production') ? `isRef` : ``);\r\n// Name mapping for runtime helpers that need to be imported from 'vue' in\r\n// generated code. Make sure these are correctly exported in the runtime!\r\n// Using `any` here because TS doesn't allow symbols as index type.\r\nconst helperNameMap = {\r\n    [FRAGMENT]: `Fragment`,\r\n    [TELEPORT]: `Teleport`,\r\n    [SUSPENSE]: `Suspense`,\r\n    [KEEP_ALIVE]: `KeepAlive`,\r\n    [BASE_TRANSITION]: `BaseTransition`,\r\n    [OPEN_BLOCK]: `openBlock`,\r\n    [CREATE_BLOCK]: `createBlock`,\r\n    [CREATE_VNODE]: `createVNode`,\r\n    [CREATE_COMMENT]: `createCommentVNode`,\r\n    [CREATE_TEXT]: `createTextVNode`,\r\n    [CREATE_STATIC]: `createStaticVNode`,\r\n    [RESOLVE_COMPONENT]: `resolveComponent`,\r\n    [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\r\n    [RESOLVE_DIRECTIVE]: `resolveDirective`,\r\n    [WITH_DIRECTIVES]: `withDirectives`,\r\n    [RENDER_LIST]: `renderList`,\r\n    [RENDER_SLOT]: `renderSlot`,\r\n    [CREATE_SLOTS]: `createSlots`,\r\n    [TO_DISPLAY_STRING]: `toDisplayString`,\r\n    [MERGE_PROPS]: `mergeProps`,\r\n    [TO_HANDLERS]: `toHandlers`,\r\n    [CAMELIZE]: `camelize`,\r\n    [CAPITALIZE]: `capitalize`,\r\n    [TO_HANDLER_KEY]: `toHandlerKey`,\r\n    [SET_BLOCK_TRACKING]: `setBlockTracking`,\r\n    [PUSH_SCOPE_ID]: `pushScopeId`,\r\n    [POP_SCOPE_ID]: `popScopeId`,\r\n    [WITH_SCOPE_ID]: `withScopeId`,\r\n    [WITH_CTX]: `withCtx`,\r\n    [UNREF]: `unref`,\r\n    [IS_REF]: `isRef`\r\n};\r\nfunction registerRuntimeHelpers(helpers) {\r\n    Object.getOwnPropertySymbols(helpers).forEach(s => {\r\n        helperNameMap[s] = helpers[s];\r\n    });\r\n}\n\n// AST Utilities ---------------------------------------------------------------\r\n// Some expressions, e.g. sequence and conditional expressions, are never\r\n// associated with template nodes, so their source locations are just a stub.\r\n// Container types like CompoundExpression also don't need a real location.\r\nconst locStub = {\r\n    source: '',\r\n    start: { line: 1, column: 1, offset: 0 },\r\n    end: { line: 1, column: 1, offset: 0 }\r\n};\r\nfunction createRoot(children, loc = locStub) {\r\n    return {\r\n        type: 0 /* ROOT */,\r\n        children,\r\n        helpers: [],\r\n        components: [],\r\n        directives: [],\r\n        hoists: [],\r\n        imports: [],\r\n        cached: 0,\r\n        temps: 0,\r\n        codegenNode: undefined,\r\n        loc\r\n    };\r\n}\r\nfunction createVNodeCall(context, tag, props, children, patchFlag, dynamicProps, directives, isBlock = false, disableTracking = false, loc = locStub) {\r\n    if (context) {\r\n        if (isBlock) {\r\n            context.helper(OPEN_BLOCK);\r\n            context.helper(CREATE_BLOCK);\r\n        }\r\n        else {\r\n            context.helper(CREATE_VNODE);\r\n        }\r\n        if (directives) {\r\n            context.helper(WITH_DIRECTIVES);\r\n        }\r\n    }\r\n    return {\r\n        type: 13 /* VNODE_CALL */,\r\n        tag,\r\n        props,\r\n        children,\r\n        patchFlag,\r\n        dynamicProps,\r\n        directives,\r\n        isBlock,\r\n        disableTracking,\r\n        loc\r\n    };\r\n}\r\nfunction createArrayExpression(elements, loc = locStub) {\r\n    return {\r\n        type: 17 /* JS_ARRAY_EXPRESSION */,\r\n        loc,\r\n        elements\r\n    };\r\n}\r\nfunction createObjectExpression(properties, loc = locStub) {\r\n    return {\r\n        type: 15 /* JS_OBJECT_EXPRESSION */,\r\n        loc,\r\n        properties\r\n    };\r\n}\r\nfunction createObjectProperty(key, value) {\r\n    return {\r\n        type: 16 /* JS_PROPERTY */,\r\n        loc: locStub,\r\n        key: isString(key) ? createSimpleExpression(key, true) : key,\r\n        value\r\n    };\r\n}\r\nfunction createSimpleExpression(content, isStatic, loc = locStub, constType = 0 /* NOT_CONSTANT */) {\r\n    return {\r\n        type: 4 /* SIMPLE_EXPRESSION */,\r\n        loc,\r\n        content,\r\n        isStatic,\r\n        constType: isStatic ? 3 /* CAN_STRINGIFY */ : constType\r\n    };\r\n}\r\nfunction createInterpolation(content, loc) {\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        loc,\r\n        content: isString(content)\r\n            ? createSimpleExpression(content, false, loc)\r\n            : content\r\n    };\r\n}\r\nfunction createCompoundExpression(children, loc = locStub) {\r\n    return {\r\n        type: 8 /* COMPOUND_EXPRESSION */,\r\n        loc,\r\n        children\r\n    };\r\n}\r\nfunction createCallExpression(callee, args = [], loc = locStub) {\r\n    return {\r\n        type: 14 /* JS_CALL_EXPRESSION */,\r\n        loc,\r\n        callee,\r\n        arguments: args\r\n    };\r\n}\r\nfunction createFunctionExpression(params, returns = undefined, newline = false, isSlot = false, loc = locStub) {\r\n    return {\r\n        type: 18 /* JS_FUNCTION_EXPRESSION */,\r\n        params,\r\n        returns,\r\n        newline,\r\n        isSlot,\r\n        loc\r\n    };\r\n}\r\nfunction createConditionalExpression(test, consequent, alternate, newline = true) {\r\n    return {\r\n        type: 19 /* JS_CONDITIONAL_EXPRESSION */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        newline,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createCacheExpression(index, value, isVNode = false) {\r\n    return {\r\n        type: 20 /* JS_CACHE_EXPRESSION */,\r\n        index,\r\n        value,\r\n        isVNode,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createBlockStatement(body) {\r\n    return {\r\n        type: 21 /* JS_BLOCK_STATEMENT */,\r\n        body,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createTemplateLiteral(elements) {\r\n    return {\r\n        type: 22 /* JS_TEMPLATE_LITERAL */,\r\n        elements,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createIfStatement(test, consequent, alternate) {\r\n    return {\r\n        type: 23 /* JS_IF_STATEMENT */,\r\n        test,\r\n        consequent,\r\n        alternate,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createAssignmentExpression(left, right) {\r\n    return {\r\n        type: 24 /* JS_ASSIGNMENT_EXPRESSION */,\r\n        left,\r\n        right,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createSequenceExpression(expressions) {\r\n    return {\r\n        type: 25 /* JS_SEQUENCE_EXPRESSION */,\r\n        expressions,\r\n        loc: locStub\r\n    };\r\n}\r\nfunction createReturnStatement(returns) {\r\n    return {\r\n        type: 26 /* JS_RETURN_STATEMENT */,\r\n        returns,\r\n        loc: locStub\r\n    };\r\n}\n\nconst isStaticExp = (p) => p.type === 4 /* SIMPLE_EXPRESSION */ && p.isStatic;\r\nconst isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);\r\nfunction isCoreComponent(tag) {\r\n    if (isBuiltInType(tag, 'Teleport')) {\r\n        return TELEPORT;\r\n    }\r\n    else if (isBuiltInType(tag, 'Suspense')) {\r\n        return SUSPENSE;\r\n    }\r\n    else if (isBuiltInType(tag, 'KeepAlive')) {\r\n        return KEEP_ALIVE;\r\n    }\r\n    else if (isBuiltInType(tag, 'BaseTransition')) {\r\n        return BASE_TRANSITION;\r\n    }\r\n}\r\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/;\r\nconst isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);\r\nconst memberExpRE = /^[A-Za-z_$\\xA0-\\uFFFF][\\w$\\xA0-\\uFFFF]*(?:\\s*\\.\\s*[A-Za-z_$\\xA0-\\uFFFF][\\w$\\xA0-\\uFFFF]*|\\[[^\\]]+\\])*$/;\r\nconst isMemberExpression = (path) => {\r\n    if (!path)\r\n        return false;\r\n    return memberExpRE.test(path.trim());\r\n};\r\nfunction getInnerRange(loc, offset, length) {\r\n    const source = loc.source.substr(offset, length);\r\n    const newLoc = {\r\n        source,\r\n        start: advancePositionWithClone(loc.start, loc.source, offset),\r\n        end: loc.end\r\n    };\r\n    if (length != null) {\r\n        newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);\r\n    }\r\n    return newLoc;\r\n}\r\nfunction advancePositionWithClone(pos, source, numberOfCharacters = source.length) {\r\n    return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);\r\n}\r\n// advance by mutation without cloning (for performance reasons), since this\r\n// gets called a lot in the parser\r\nfunction advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {\r\n    let linesCount = 0;\r\n    let lastNewLinePos = -1;\r\n    for (let i = 0; i < numberOfCharacters; i++) {\r\n        if (source.charCodeAt(i) === 10 /* newline char code */) {\r\n            linesCount++;\r\n            lastNewLinePos = i;\r\n        }\r\n    }\r\n    pos.offset += numberOfCharacters;\r\n    pos.line += linesCount;\r\n    pos.column =\r\n        lastNewLinePos === -1\r\n            ? pos.column + numberOfCharacters\r\n            : numberOfCharacters - lastNewLinePos;\r\n    return pos;\r\n}\r\nfunction assert(condition, msg) {\r\n    /* istanbul ignore if */\r\n    if (!condition) {\r\n        throw new Error(msg || `unexpected compiler condition`);\r\n    }\r\n}\r\nfunction findDir(node, name, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 7 /* DIRECTIVE */ &&\r\n            (allowEmpty || p.exp) &&\r\n            (isString(name) ? p.name === name : name.test(p.name))) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction findProp(node, name, dynamicOnly = false, allowEmpty = false) {\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (dynamicOnly)\r\n                continue;\r\n            if (p.name === name && (p.value || allowEmpty)) {\r\n                return p;\r\n            }\r\n        }\r\n        else if (p.name === 'bind' &&\r\n            (p.exp || allowEmpty) &&\r\n            isBindKey(p.arg, name)) {\r\n            return p;\r\n        }\r\n    }\r\n}\r\nfunction isBindKey(arg, name) {\r\n    return !!(arg && isStaticExp(arg) && arg.content === name);\r\n}\r\nfunction hasDynamicKeyVBind(node) {\r\n    return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&\r\n        p.name === 'bind' &&\r\n        (!p.arg || // v-bind=\"obj\"\r\n            p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]\r\n            !p.arg.isStatic) // v-bind:[foo]\r\n    );\r\n}\r\nfunction isText(node) {\r\n    return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;\r\n}\r\nfunction isVSlot(p) {\r\n    return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';\r\n}\r\nfunction isTemplateNode(node) {\r\n    return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);\r\n}\r\nfunction isSlotOutlet(node) {\r\n    return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;\r\n}\r\nfunction injectProp(node, prop, context) {\r\n    let propsWithInjection;\r\n    const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];\r\n    if (props == null || isString(props)) {\r\n        propsWithInjection = createObjectExpression([prop]);\r\n    }\r\n    else if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n        // merged props... add ours\r\n        // only inject key to object literal if it's the first argument so that\r\n        // if doesn't override user provided keys\r\n        const first = props.arguments[0];\r\n        if (!isString(first) && first.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n            first.properties.unshift(prop);\r\n        }\r\n        else {\r\n            if (props.callee === TO_HANDLERS) {\r\n                // #2366\r\n                propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n                    createObjectExpression([prop]),\r\n                    props\r\n                ]);\r\n            }\r\n            else {\r\n                props.arguments.unshift(createObjectExpression([prop]));\r\n            }\r\n        }\r\n        !propsWithInjection && (propsWithInjection = props);\r\n    }\r\n    else if (props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        let alreadyExists = false;\r\n        // check existing key to avoid overriding user provided keys\r\n        if (prop.key.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            const propKeyName = prop.key.content;\r\n            alreadyExists = props.properties.some(p => p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                p.key.content === propKeyName);\r\n        }\r\n        if (!alreadyExists) {\r\n            props.properties.unshift(prop);\r\n        }\r\n        propsWithInjection = props;\r\n    }\r\n    else {\r\n        // single v-bind with expression, return a merged replacement\r\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\r\n            createObjectExpression([prop]),\r\n            props\r\n        ]);\r\n    }\r\n    if (node.type === 13 /* VNODE_CALL */) {\r\n        node.props = propsWithInjection;\r\n    }\r\n    else {\r\n        node.arguments[2] = propsWithInjection;\r\n    }\r\n}\r\nfunction toValidAssetId(name, type) {\r\n    return `_${type}_${name.replace(/[^\\w]/g, '_')}`;\r\n}\r\n// Check if a node contains expressions that reference current context scope ids\r\nfunction hasScopeRef(node, ids) {\r\n    if (!node || Object.keys(ids).length === 0) {\r\n        return false;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            for (let i = 0; i < node.props.length; i++) {\r\n                const p = node.props[i];\r\n                if (p.type === 7 /* DIRECTIVE */ &&\r\n                    (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))) {\r\n                    return true;\r\n                }\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 11 /* FOR */:\r\n            if (hasScopeRef(node.source, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 9 /* IF */:\r\n            return node.branches.some(b => hasScopeRef(b, ids));\r\n        case 10 /* IF_BRANCH */:\r\n            if (hasScopeRef(node.condition, ids)) {\r\n                return true;\r\n            }\r\n            return node.children.some(c => hasScopeRef(c, ids));\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return (!node.isStatic &&\r\n                isSimpleIdentifier(node.content) &&\r\n                !!ids[node.content]);\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            return node.children.some(c => isObject(c) && hasScopeRef(c, ids));\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return hasScopeRef(node.content, ids);\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return false;\r\n        default:\r\n            if ((process.env.NODE_ENV !== 'production')) ;\r\n            return false;\r\n    }\r\n}\n\n// The default decoder only provides escapes for characters reserved as part of\r\n// the template syntax, and is only used if the custom renderer did not provide\r\n// a platform-specific decoder.\r\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g;\r\nconst decodeMap = {\r\n    gt: '>',\r\n    lt: '<',\r\n    amp: '&',\r\n    apos: \"'\",\r\n    quot: '\"'\r\n};\r\nconst defaultParserOptions = {\r\n    delimiters: [`{{`, `}}`],\r\n    getNamespace: () => 0 /* HTML */,\r\n    getTextMode: () => 0 /* DATA */,\r\n    isVoidTag: NO,\r\n    isPreTag: NO,\r\n    isCustomElement: NO,\r\n    decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\r\n    onError: defaultOnError,\r\n    comments: false\r\n};\r\nfunction baseParse(content, options = {}) {\r\n    const context = createParserContext(content, options);\r\n    const start = getCursor(context);\r\n    return createRoot(parseChildren(context, 0 /* DATA */, []), getSelection(context, start));\r\n}\r\nfunction createParserContext(content, rawOptions) {\r\n    const options = extend({}, defaultParserOptions);\r\n    for (const key in rawOptions) {\r\n        // @ts-ignore\r\n        options[key] = rawOptions[key] || defaultParserOptions[key];\r\n    }\r\n    return {\r\n        options,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        originalSource: content,\r\n        source: content,\r\n        inPre: false,\r\n        inVPre: false\r\n    };\r\n}\r\nfunction parseChildren(context, mode, ancestors) {\r\n    const parent = last(ancestors);\r\n    const ns = parent ? parent.ns : 0 /* HTML */;\r\n    const nodes = [];\r\n    while (!isEnd(context, mode, ancestors)) {\r\n        const s = context.source;\r\n        let node = undefined;\r\n        if (mode === 0 /* DATA */ || mode === 1 /* RCDATA */) {\r\n            if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\r\n                // '{{'\r\n                node = parseInterpolation(context, mode);\r\n            }\r\n            else if (mode === 0 /* DATA */ && s[0] === '<') {\r\n                // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\r\n                if (s.length === 1) {\r\n                    emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 1);\r\n                }\r\n                else if (s[1] === '!') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\r\n                    if (startsWith(s, '<!--')) {\r\n                        node = parseComment(context);\r\n                    }\r\n                    else if (startsWith(s, '<!DOCTYPE')) {\r\n                        // Ignore DOCTYPE by a limitation.\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                    else if (startsWith(s, '<![CDATA[')) {\r\n                        if (ns !== 0 /* HTML */) {\r\n                            node = parseCDATA(context, ancestors);\r\n                        }\r\n                        else {\r\n                            emitError(context, 1 /* CDATA_IN_HTML_CONTENT */);\r\n                            node = parseBogusComment(context);\r\n                        }\r\n                    }\r\n                    else {\r\n                        emitError(context, 11 /* INCORRECTLY_OPENED_COMMENT */);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (s[1] === '/') {\r\n                    // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\r\n                    if (s.length === 2) {\r\n                        emitError(context, 5 /* EOF_BEFORE_TAG_NAME */, 2);\r\n                    }\r\n                    else if (s[2] === '>') {\r\n                        emitError(context, 14 /* MISSING_END_TAG_NAME */, 2);\r\n                        advanceBy(context, 3);\r\n                        continue;\r\n                    }\r\n                    else if (/[a-z]/i.test(s[2])) {\r\n                        emitError(context, 23 /* X_INVALID_END_TAG */);\r\n                        parseTag(context, 1 /* End */, parent);\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 2);\r\n                        node = parseBogusComment(context);\r\n                    }\r\n                }\r\n                else if (/[a-z]/i.test(s[1])) {\r\n                    node = parseElement(context, ancestors);\r\n                }\r\n                else if (s[1] === '?') {\r\n                    emitError(context, 21 /* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */, 1);\r\n                    node = parseBogusComment(context);\r\n                }\r\n                else {\r\n                    emitError(context, 12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */, 1);\r\n                }\r\n            }\r\n        }\r\n        if (!node) {\r\n            node = parseText(context, mode);\r\n        }\r\n        if (isArray(node)) {\r\n            for (let i = 0; i < node.length; i++) {\r\n                pushNode(nodes, node[i]);\r\n            }\r\n        }\r\n        else {\r\n            pushNode(nodes, node);\r\n        }\r\n    }\r\n    // Whitespace management for more efficient output\r\n    // (same as v2 whitespace: 'condense')\r\n    let removedWhitespace = false;\r\n    if (mode !== 2 /* RAWTEXT */ && mode !== 1 /* RCDATA */) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            if (!context.inPre && node.type === 2 /* TEXT */) {\r\n                if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\r\n                    const prev = nodes[i - 1];\r\n                    const next = nodes[i + 1];\r\n                    // If:\r\n                    // - the whitespace is the first or last node, or:\r\n                    // - the whitespace is adjacent to a comment, or:\r\n                    // - the whitespace is between two elements AND contains newline\r\n                    // Then the whitespace is ignored.\r\n                    if (!prev ||\r\n                        !next ||\r\n                        prev.type === 3 /* COMMENT */ ||\r\n                        next.type === 3 /* COMMENT */ ||\r\n                        (prev.type === 1 /* ELEMENT */ &&\r\n                            next.type === 1 /* ELEMENT */ &&\r\n                            /[\\r\\n]/.test(node.content))) {\r\n                        removedWhitespace = true;\r\n                        nodes[i] = null;\r\n                    }\r\n                    else {\r\n                        // Otherwise, condensed consecutive whitespace inside the text\r\n                        // down to a single space\r\n                        node.content = ' ';\r\n                    }\r\n                }\r\n                else {\r\n                    node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ');\r\n                }\r\n            }\r\n            // also remove comment nodes in prod by default\r\n            if (!(process.env.NODE_ENV !== 'production') &&\r\n                node.type === 3 /* COMMENT */ &&\r\n                !context.options.comments) {\r\n                removedWhitespace = true;\r\n                nodes[i] = null;\r\n            }\r\n        }\r\n        if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\r\n            // remove leading newline per html spec\r\n            // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\r\n            const first = nodes[0];\r\n            if (first && first.type === 2 /* TEXT */) {\r\n                first.content = first.content.replace(/^\\r?\\n/, '');\r\n            }\r\n        }\r\n    }\r\n    return removedWhitespace ? nodes.filter(Boolean) : nodes;\r\n}\r\nfunction pushNode(nodes, node) {\r\n    if (node.type === 2 /* TEXT */) {\r\n        const prev = last(nodes);\r\n        // Merge if both this and the previous node are text and those are\r\n        // consecutive. This happens for cases like \"a < b\".\r\n        if (prev &&\r\n            prev.type === 2 /* TEXT */ &&\r\n            prev.loc.end.offset === node.loc.start.offset) {\r\n            prev.content += node.content;\r\n            prev.loc.end = node.loc.end;\r\n            prev.loc.source += node.loc.source;\r\n            return;\r\n        }\r\n    }\r\n    nodes.push(node);\r\n}\r\nfunction parseCDATA(context, ancestors) {\r\n    advanceBy(context, 9);\r\n    const nodes = parseChildren(context, 3 /* CDATA */, ancestors);\r\n    if (context.source.length === 0) {\r\n        emitError(context, 6 /* EOF_IN_CDATA */);\r\n    }\r\n    else {\r\n        advanceBy(context, 3);\r\n    }\r\n    return nodes;\r\n}\r\nfunction parseComment(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    // Regular comment.\r\n    const match = /--(\\!)?>/.exec(context.source);\r\n    if (!match) {\r\n        content = context.source.slice(4);\r\n        advanceBy(context, context.source.length);\r\n        emitError(context, 7 /* EOF_IN_COMMENT */);\r\n    }\r\n    else {\r\n        if (match.index <= 3) {\r\n            emitError(context, 0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);\r\n        }\r\n        if (match[1]) {\r\n            emitError(context, 10 /* INCORRECTLY_CLOSED_COMMENT */);\r\n        }\r\n        content = context.source.slice(4, match.index);\r\n        // Advancing with reporting nested comments.\r\n        const s = context.source.slice(0, match.index);\r\n        let prevIndex = 1, nestedIndex = 0;\r\n        while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\r\n            advanceBy(context, nestedIndex - prevIndex + 1);\r\n            if (nestedIndex + 4 < s.length) {\r\n                emitError(context, 16 /* NESTED_COMMENT */);\r\n            }\r\n            prevIndex = nestedIndex + 1;\r\n        }\r\n        advanceBy(context, match.index + match[0].length - prevIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseBogusComment(context) {\r\n    const start = getCursor(context);\r\n    const contentStart = context.source[1] === '?' ? 1 : 2;\r\n    let content;\r\n    const closeIndex = context.source.indexOf('>');\r\n    if (closeIndex === -1) {\r\n        content = context.source.slice(contentStart);\r\n        advanceBy(context, context.source.length);\r\n    }\r\n    else {\r\n        content = context.source.slice(contentStart, closeIndex);\r\n        advanceBy(context, closeIndex + 1);\r\n    }\r\n    return {\r\n        type: 3 /* COMMENT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseElement(context, ancestors) {\r\n    // Start tag.\r\n    const wasInPre = context.inPre;\r\n    const wasInVPre = context.inVPre;\r\n    const parent = last(ancestors);\r\n    const element = parseTag(context, 0 /* Start */, parent);\r\n    const isPreBoundary = context.inPre && !wasInPre;\r\n    const isVPreBoundary = context.inVPre && !wasInVPre;\r\n    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\r\n        return element;\r\n    }\r\n    // Children.\r\n    ancestors.push(element);\r\n    const mode = context.options.getTextMode(element, parent);\r\n    const children = parseChildren(context, mode, ancestors);\r\n    ancestors.pop();\r\n    element.children = children;\r\n    // End tag.\r\n    if (startsWithEndTagOpen(context.source, element.tag)) {\r\n        parseTag(context, 1 /* End */, parent);\r\n    }\r\n    else {\r\n        emitError(context, 24 /* X_MISSING_END_TAG */, 0, element.loc.start);\r\n        if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\r\n            const first = children[0];\r\n            if (first && startsWith(first.loc.source, '<!--')) {\r\n                emitError(context, 8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);\r\n            }\r\n        }\r\n    }\r\n    element.loc = getSelection(context, element.loc.start);\r\n    if (isPreBoundary) {\r\n        context.inPre = false;\r\n    }\r\n    if (isVPreBoundary) {\r\n        context.inVPre = false;\r\n    }\r\n    return element;\r\n}\r\nconst isSpecialTemplateDirective = /*#__PURE__*/ makeMap(`if,else,else-if,for,slot`);\r\n/**\r\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\r\n */\r\nfunction parseTag(context, type, parent) {\r\n    // Tag open.\r\n    const start = getCursor(context);\r\n    const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source);\r\n    const tag = match[1];\r\n    const ns = context.options.getNamespace(tag, parent);\r\n    advanceBy(context, match[0].length);\r\n    advanceSpaces(context);\r\n    // save current state in case we need to re-parse attributes with v-pre\r\n    const cursor = getCursor(context);\r\n    const currentSource = context.source;\r\n    // Attributes.\r\n    let props = parseAttributes(context, type);\r\n    // check <pre> tag\r\n    if (context.options.isPreTag(tag)) {\r\n        context.inPre = true;\r\n    }\r\n    // check v-pre\r\n    if (!context.inVPre &&\r\n        props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'pre')) {\r\n        context.inVPre = true;\r\n        // reset context\r\n        extend(context, cursor);\r\n        context.source = currentSource;\r\n        // re-parse attrs and filter out v-pre itself\r\n        props = parseAttributes(context, type).filter(p => p.name !== 'v-pre');\r\n    }\r\n    // Tag close.\r\n    let isSelfClosing = false;\r\n    if (context.source.length === 0) {\r\n        emitError(context, 9 /* EOF_IN_TAG */);\r\n    }\r\n    else {\r\n        isSelfClosing = startsWith(context.source, '/>');\r\n        if (type === 1 /* End */ && isSelfClosing) {\r\n            emitError(context, 4 /* END_TAG_WITH_TRAILING_SOLIDUS */);\r\n        }\r\n        advanceBy(context, isSelfClosing ? 2 : 1);\r\n    }\r\n    let tagType = 0 /* ELEMENT */;\r\n    const options = context.options;\r\n    if (!context.inVPre && !options.isCustomElement(tag)) {\r\n        const hasVIs = props.some(p => p.type === 7 /* DIRECTIVE */ && p.name === 'is');\r\n        if (options.isNativeTag && !hasVIs) {\r\n            if (!options.isNativeTag(tag))\r\n                tagType = 1 /* COMPONENT */;\r\n        }\r\n        else if (hasVIs ||\r\n            isCoreComponent(tag) ||\r\n            (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\r\n            /^[A-Z]/.test(tag) ||\r\n            tag === 'component') {\r\n            tagType = 1 /* COMPONENT */;\r\n        }\r\n        if (tag === 'slot') {\r\n            tagType = 2 /* SLOT */;\r\n        }\r\n        else if (tag === 'template' &&\r\n            props.some(p => {\r\n                return (p.type === 7 /* DIRECTIVE */ && isSpecialTemplateDirective(p.name));\r\n            })) {\r\n            tagType = 3 /* TEMPLATE */;\r\n        }\r\n    }\r\n    return {\r\n        type: 1 /* ELEMENT */,\r\n        ns,\r\n        tag,\r\n        tagType,\r\n        props,\r\n        isSelfClosing,\r\n        children: [],\r\n        loc: getSelection(context, start),\r\n        codegenNode: undefined // to be created during transform phase\r\n    };\r\n}\r\nfunction parseAttributes(context, type) {\r\n    const props = [];\r\n    const attributeNames = new Set();\r\n    while (context.source.length > 0 &&\r\n        !startsWith(context.source, '>') &&\r\n        !startsWith(context.source, '/>')) {\r\n        if (startsWith(context.source, '/')) {\r\n            emitError(context, 22 /* UNEXPECTED_SOLIDUS_IN_TAG */);\r\n            advanceBy(context, 1);\r\n            advanceSpaces(context);\r\n            continue;\r\n        }\r\n        if (type === 1 /* End */) {\r\n            emitError(context, 3 /* END_TAG_WITH_ATTRIBUTES */);\r\n        }\r\n        const attr = parseAttribute(context, attributeNames);\r\n        if (type === 0 /* Start */) {\r\n            props.push(attr);\r\n        }\r\n        if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\r\n            emitError(context, 15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);\r\n        }\r\n        advanceSpaces(context);\r\n    }\r\n    return props;\r\n}\r\nfunction parseAttribute(context, nameSet) {\r\n    // Name.\r\n    const start = getCursor(context);\r\n    const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source);\r\n    const name = match[0];\r\n    if (nameSet.has(name)) {\r\n        emitError(context, 2 /* DUPLICATE_ATTRIBUTE */);\r\n    }\r\n    nameSet.add(name);\r\n    if (name[0] === '=') {\r\n        emitError(context, 19 /* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);\r\n    }\r\n    {\r\n        const pattern = /[\"'<]/g;\r\n        let m;\r\n        while ((m = pattern.exec(name))) {\r\n            emitError(context, 17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */, m.index);\r\n        }\r\n    }\r\n    advanceBy(context, name.length);\r\n    // Value\r\n    let value = undefined;\r\n    if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\r\n        advanceSpaces(context);\r\n        advanceBy(context, 1);\r\n        advanceSpaces(context);\r\n        value = parseAttributeValue(context);\r\n        if (!value) {\r\n            emitError(context, 13 /* MISSING_ATTRIBUTE_VALUE */);\r\n        }\r\n    }\r\n    const loc = getSelection(context, start);\r\n    if (!context.inVPre && /^(v-|:|@|#)/.test(name)) {\r\n        const match = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(name);\r\n        const dirName = match[1] ||\r\n            (startsWith(name, ':') ? 'bind' : startsWith(name, '@') ? 'on' : 'slot');\r\n        let arg;\r\n        if (match[2]) {\r\n            const isSlot = dirName === 'slot';\r\n            const startOffset = name.lastIndexOf(match[2]);\r\n            const loc = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match[2].length + ((isSlot && match[3]) || '').length));\r\n            let content = match[2];\r\n            let isStatic = true;\r\n            if (content.startsWith('[')) {\r\n                isStatic = false;\r\n                if (!content.endsWith(']')) {\r\n                    emitError(context, 26 /* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);\r\n                }\r\n                content = content.substr(1, content.length - 2);\r\n            }\r\n            else if (isSlot) {\r\n                // #1241 special case for v-slot: vuetify relies extensively on slot\r\n                // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\r\n                // supports such usage so we are keeping it consistent with 2.x.\r\n                content += match[3] || '';\r\n            }\r\n            arg = {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content,\r\n                isStatic,\r\n                constType: isStatic\r\n                    ? 3 /* CAN_STRINGIFY */\r\n                    : 0 /* NOT_CONSTANT */,\r\n                loc\r\n            };\r\n        }\r\n        if (value && value.isQuoted) {\r\n            const valueLoc = value.loc;\r\n            valueLoc.start.offset++;\r\n            valueLoc.start.column++;\r\n            valueLoc.end = advancePositionWithClone(valueLoc.start, value.content);\r\n            valueLoc.source = valueLoc.source.slice(1, -1);\r\n        }\r\n        return {\r\n            type: 7 /* DIRECTIVE */,\r\n            name: dirName,\r\n            exp: value && {\r\n                type: 4 /* SIMPLE_EXPRESSION */,\r\n                content: value.content,\r\n                isStatic: false,\r\n                // Treat as non-constant by default. This can be potentially set to\r\n                // other values by `transformExpression` to make it eligible for hoisting.\r\n                constType: 0 /* NOT_CONSTANT */,\r\n                loc: value.loc\r\n            },\r\n            arg,\r\n            modifiers: match[3] ? match[3].substr(1).split('.') : [],\r\n            loc\r\n        };\r\n    }\r\n    return {\r\n        type: 6 /* ATTRIBUTE */,\r\n        name,\r\n        value: value && {\r\n            type: 2 /* TEXT */,\r\n            content: value.content,\r\n            loc: value.loc\r\n        },\r\n        loc\r\n    };\r\n}\r\nfunction parseAttributeValue(context) {\r\n    const start = getCursor(context);\r\n    let content;\r\n    const quote = context.source[0];\r\n    const isQuoted = quote === `\"` || quote === `'`;\r\n    if (isQuoted) {\r\n        // Quoted value.\r\n        advanceBy(context, 1);\r\n        const endIndex = context.source.indexOf(quote);\r\n        if (endIndex === -1) {\r\n            content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);\r\n        }\r\n        else {\r\n            content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);\r\n            advanceBy(context, 1);\r\n        }\r\n    }\r\n    else {\r\n        // Unquoted\r\n        const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source);\r\n        if (!match) {\r\n            return undefined;\r\n        }\r\n        const unexpectedChars = /[\"'<=`]/g;\r\n        let m;\r\n        while ((m = unexpectedChars.exec(match[0]))) {\r\n            emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);\r\n        }\r\n        content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n    return { content, isQuoted, loc: getSelection(context, start) };\r\n}\r\nfunction parseInterpolation(context, mode) {\r\n    const [open, close] = context.options.delimiters;\r\n    const closeIndex = context.source.indexOf(close, open.length);\r\n    if (closeIndex === -1) {\r\n        emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);\r\n        return undefined;\r\n    }\r\n    const start = getCursor(context);\r\n    advanceBy(context, open.length);\r\n    const innerStart = getCursor(context);\r\n    const innerEnd = getCursor(context);\r\n    const rawContentLength = closeIndex - open.length;\r\n    const rawContent = context.source.slice(0, rawContentLength);\r\n    const preTrimContent = parseTextData(context, rawContentLength, mode);\r\n    const content = preTrimContent.trim();\r\n    const startOffset = preTrimContent.indexOf(content);\r\n    if (startOffset > 0) {\r\n        advancePositionWithMutation(innerStart, rawContent, startOffset);\r\n    }\r\n    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);\r\n    advancePositionWithMutation(innerEnd, rawContent, endOffset);\r\n    advanceBy(context, close.length);\r\n    return {\r\n        type: 5 /* INTERPOLATION */,\r\n        content: {\r\n            type: 4 /* SIMPLE_EXPRESSION */,\r\n            isStatic: false,\r\n            // Set `isConstant` to false by default and will decide in transformExpression\r\n            constType: 0 /* NOT_CONSTANT */,\r\n            content,\r\n            loc: getSelection(context, innerStart, innerEnd)\r\n        },\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\nfunction parseText(context, mode) {\r\n    const endTokens = ['<', context.options.delimiters[0]];\r\n    if (mode === 3 /* CDATA */) {\r\n        endTokens.push(']]>');\r\n    }\r\n    let endIndex = context.source.length;\r\n    for (let i = 0; i < endTokens.length; i++) {\r\n        const index = context.source.indexOf(endTokens[i], 1);\r\n        if (index !== -1 && endIndex > index) {\r\n            endIndex = index;\r\n        }\r\n    }\r\n    const start = getCursor(context);\r\n    const content = parseTextData(context, endIndex, mode);\r\n    return {\r\n        type: 2 /* TEXT */,\r\n        content,\r\n        loc: getSelection(context, start)\r\n    };\r\n}\r\n/**\r\n * Get text data with a given length from the current location.\r\n * This translates HTML entities in the text data.\r\n */\r\nfunction parseTextData(context, length, mode) {\r\n    const rawText = context.source.slice(0, length);\r\n    advanceBy(context, length);\r\n    if (mode === 2 /* RAWTEXT */ ||\r\n        mode === 3 /* CDATA */ ||\r\n        rawText.indexOf('&') === -1) {\r\n        return rawText;\r\n    }\r\n    else {\r\n        // DATA or RCDATA containing \"&\"\". Entity decoding required.\r\n        return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);\r\n    }\r\n}\r\nfunction getCursor(context) {\r\n    const { column, line, offset } = context;\r\n    return { column, line, offset };\r\n}\r\nfunction getSelection(context, start, end) {\r\n    end = end || getCursor(context);\r\n    return {\r\n        start,\r\n        end,\r\n        source: context.originalSource.slice(start.offset, end.offset)\r\n    };\r\n}\r\nfunction last(xs) {\r\n    return xs[xs.length - 1];\r\n}\r\nfunction startsWith(source, searchString) {\r\n    return source.startsWith(searchString);\r\n}\r\nfunction advanceBy(context, numberOfCharacters) {\r\n    const { source } = context;\r\n    advancePositionWithMutation(context, source, numberOfCharacters);\r\n    context.source = source.slice(numberOfCharacters);\r\n}\r\nfunction advanceSpaces(context) {\r\n    const match = /^[\\t\\r\\n\\f ]+/.exec(context.source);\r\n    if (match) {\r\n        advanceBy(context, match[0].length);\r\n    }\r\n}\r\nfunction getNewPosition(context, start, numberOfCharacters) {\r\n    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);\r\n}\r\nfunction emitError(context, code, offset, loc = getCursor(context)) {\r\n    if (offset) {\r\n        loc.offset += offset;\r\n        loc.column += offset;\r\n    }\r\n    context.options.onError(createCompilerError(code, {\r\n        start: loc,\r\n        end: loc,\r\n        source: ''\r\n    }));\r\n}\r\nfunction isEnd(context, mode, ancestors) {\r\n    const s = context.source;\r\n    switch (mode) {\r\n        case 0 /* DATA */:\r\n            if (startsWith(s, '</')) {\r\n                // TODO: probably bad performance\r\n                for (let i = ancestors.length - 1; i >= 0; --i) {\r\n                    if (startsWithEndTagOpen(s, ancestors[i].tag)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case 1 /* RCDATA */:\r\n        case 2 /* RAWTEXT */: {\r\n            const parent = last(ancestors);\r\n            if (parent && startsWithEndTagOpen(s, parent.tag)) {\r\n                return true;\r\n            }\r\n            break;\r\n        }\r\n        case 3 /* CDATA */:\r\n            if (startsWith(s, ']]>')) {\r\n                return true;\r\n            }\r\n            break;\r\n    }\r\n    return !s;\r\n}\r\nfunction startsWithEndTagOpen(source, tag) {\r\n    return (startsWith(source, '</') &&\r\n        source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&\r\n        /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>'));\r\n}\n\nfunction hoistStatic(root, context) {\r\n    walk(root, context, \r\n    // Root node is unfortunately non-hoistable due to potential parent\r\n    // fallthrough attributes.\r\n    isSingleElementRoot(root, root.children[0]));\r\n}\r\nfunction isSingleElementRoot(root, child) {\r\n    const { children } = root;\r\n    return (children.length === 1 &&\r\n        child.type === 1 /* ELEMENT */ &&\r\n        !isSlotOutlet(child));\r\n}\r\nfunction walk(node, context, doNotHoistNode = false) {\r\n    let hasHoistedNode = false;\r\n    // Some transforms, e.g. transformAssetUrls from @vue/compiler-sfc, replaces\r\n    // static bindings with expressions. These expressions are guaranteed to be\r\n    // constant so they are still eligible for hoisting, but they are only\r\n    // available at runtime and therefore cannot be evaluated ahead of time.\r\n    // This is only a concern for pre-stringification (via transformHoist by\r\n    // @vue/compiler-dom), but doing it here allows us to perform only one full\r\n    // walk of the AST and allow `stringifyStatic` to stop walking as soon as its\r\n    // stringficiation threshold is met.\r\n    let canStringify = true;\r\n    const { children } = node;\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        // only plain elements & text calls are eligible for hoisting.\r\n        if (child.type === 1 /* ELEMENT */ &&\r\n            child.tagType === 0 /* ELEMENT */) {\r\n            const constantType = doNotHoistNode\r\n                ? 0 /* NOT_CONSTANT */\r\n                : getConstantType(child, context);\r\n            if (constantType > 0 /* NOT_CONSTANT */) {\r\n                if (constantType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (constantType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode.patchFlag =\r\n                        -1 /* HOISTED */ + ((process.env.NODE_ENV !== 'production') ? ` /* HOISTED */` : ``);\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                // node may contain dynamic children, but its props may be eligible for\r\n                // hoisting.\r\n                const codegenNode = child.codegenNode;\r\n                if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                    const flag = getPatchFlag(codegenNode);\r\n                    if ((!flag ||\r\n                        flag === 512 /* NEED_PATCH */ ||\r\n                        flag === 1 /* TEXT */) &&\r\n                        getGeneratedPropsConstantType(child, context) >=\r\n                            2 /* CAN_HOIST */) {\r\n                        const props = getNodeProps(child);\r\n                        if (props) {\r\n                            codegenNode.props = context.hoist(props);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (child.type === 12 /* TEXT_CALL */) {\r\n            const contentType = getConstantType(child.content, context);\r\n            if (contentType > 0) {\r\n                if (contentType < 3 /* CAN_STRINGIFY */) {\r\n                    canStringify = false;\r\n                }\r\n                if (contentType >= 2 /* CAN_HOIST */) {\r\n                    child.codegenNode = context.hoist(child.codegenNode);\r\n                    hasHoistedNode = true;\r\n                }\r\n            }\r\n        }\r\n        // walk further\r\n        if (child.type === 1 /* ELEMENT */) {\r\n            const isComponent = child.tagType === 1 /* COMPONENT */;\r\n            if (isComponent) {\r\n                context.scopes.vSlot++;\r\n            }\r\n            walk(child, context);\r\n            if (isComponent) {\r\n                context.scopes.vSlot--;\r\n            }\r\n        }\r\n        else if (child.type === 11 /* FOR */) {\r\n            // Do not hoist v-for single child because it has to be a block\r\n            walk(child, context, child.children.length === 1);\r\n        }\r\n        else if (child.type === 9 /* IF */) {\r\n            for (let i = 0; i < child.branches.length; i++) {\r\n                // Do not hoist v-if single child because it has to be a block\r\n                walk(child.branches[i], context, child.branches[i].children.length === 1);\r\n            }\r\n        }\r\n    }\r\n    if (canStringify && hasHoistedNode && context.transformHoist) {\r\n        context.transformHoist(children, context, node);\r\n    }\r\n}\r\nfunction getConstantType(node, context) {\r\n    const { constantCache } = context;\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n            if (node.tagType !== 0 /* ELEMENT */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const cached = constantCache.get(node);\r\n            if (cached !== undefined) {\r\n                return cached;\r\n            }\r\n            const codegenNode = node.codegenNode;\r\n            if (codegenNode.type !== 13 /* VNODE_CALL */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const flag = getPatchFlag(codegenNode);\r\n            if (!flag) {\r\n                let returnType = 3 /* CAN_STRINGIFY */;\r\n                // Element itself has no patch flag. However we still need to check:\r\n                // 1. Even for a node with no patch flag, it is possible for it to contain\r\n                // non-hoistable expressions that refers to scope variables, e.g. compiler\r\n                // injected keys or cached event handlers. Therefore we need to always\r\n                // check the codegenNode's props to be sure.\r\n                const generatedPropsType = getGeneratedPropsConstantType(node, context);\r\n                if (generatedPropsType === 0 /* NOT_CONSTANT */) {\r\n                    constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                if (generatedPropsType < returnType) {\r\n                    returnType = generatedPropsType;\r\n                }\r\n                // 2. its children.\r\n                for (let i = 0; i < node.children.length; i++) {\r\n                    const childType = getConstantType(node.children[i], context);\r\n                    if (childType === 0 /* NOT_CONSTANT */) {\r\n                        constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                        return 0 /* NOT_CONSTANT */;\r\n                    }\r\n                    if (childType < returnType) {\r\n                        returnType = childType;\r\n                    }\r\n                }\r\n                // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\r\n                // type, check if any of the props can cause the type to be lowered\r\n                // we can skip can_patch because it's guaranteed by the absence of a\r\n                // patchFlag.\r\n                if (returnType > 1 /* CAN_SKIP_PATCH */) {\r\n                    for (let i = 0; i < node.props.length; i++) {\r\n                        const p = node.props[i];\r\n                        if (p.type === 7 /* DIRECTIVE */ && p.name === 'bind' && p.exp) {\r\n                            const expType = getConstantType(p.exp, context);\r\n                            if (expType === 0 /* NOT_CONSTANT */) {\r\n                                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                                return 0 /* NOT_CONSTANT */;\r\n                            }\r\n                            if (expType < returnType) {\r\n                                returnType = expType;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // only svg/foreignObject could be block here, however if they are\r\n                // static then they don't need to be blocks since there will be no\r\n                // nested updates.\r\n                if (codegenNode.isBlock) {\r\n                    context.removeHelper(OPEN_BLOCK);\r\n                    context.removeHelper(CREATE_BLOCK);\r\n                    codegenNode.isBlock = false;\r\n                    context.helper(CREATE_VNODE);\r\n                }\r\n                constantCache.set(node, returnType);\r\n                return returnType;\r\n            }\r\n            else {\r\n                constantCache.set(node, 0 /* NOT_CONSTANT */);\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n        case 2 /* TEXT */:\r\n        case 3 /* COMMENT */:\r\n            return 3 /* CAN_STRINGIFY */;\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n        case 10 /* IF_BRANCH */:\r\n            return 0 /* NOT_CONSTANT */;\r\n        case 5 /* INTERPOLATION */:\r\n        case 12 /* TEXT_CALL */:\r\n            return getConstantType(node.content, context);\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            return node.constType;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            let returnType = 3 /* CAN_STRINGIFY */;\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                const child = node.children[i];\r\n                if (isString(child) || isSymbol(child)) {\r\n                    continue;\r\n                }\r\n                const childType = getConstantType(child, context);\r\n                if (childType === 0 /* NOT_CONSTANT */) {\r\n                    return 0 /* NOT_CONSTANT */;\r\n                }\r\n                else if (childType < returnType) {\r\n                    returnType = childType;\r\n                }\r\n            }\r\n            return returnType;\r\n        default:\r\n            if ((process.env.NODE_ENV !== 'production')) ;\r\n            return 0 /* NOT_CONSTANT */;\r\n    }\r\n}\r\nfunction getGeneratedPropsConstantType(node, context) {\r\n    let returnType = 3 /* CAN_STRINGIFY */;\r\n    const props = getNodeProps(node);\r\n    if (props && props.type === 15 /* JS_OBJECT_EXPRESSION */) {\r\n        const { properties } = props;\r\n        for (let i = 0; i < properties.length; i++) {\r\n            const { key, value } = properties[i];\r\n            const keyType = getConstantType(key, context);\r\n            if (keyType === 0 /* NOT_CONSTANT */) {\r\n                return keyType;\r\n            }\r\n            if (keyType < returnType) {\r\n                returnType = keyType;\r\n            }\r\n            if (value.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n                return 0 /* NOT_CONSTANT */;\r\n            }\r\n            const valueType = getConstantType(value, context);\r\n            if (valueType === 0 /* NOT_CONSTANT */) {\r\n                return valueType;\r\n            }\r\n            if (valueType < returnType) {\r\n                returnType = valueType;\r\n            }\r\n        }\r\n    }\r\n    return returnType;\r\n}\r\nfunction getNodeProps(node) {\r\n    const codegenNode = node.codegenNode;\r\n    if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n        return codegenNode.props;\r\n    }\r\n}\r\nfunction getPatchFlag(node) {\r\n    const flag = node.patchFlag;\r\n    return flag ? parseInt(flag, 10) : undefined;\r\n}\n\nfunction createTransformContext(root, { filename = '', prefixIdentifiers = false, hoistStatic = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError }) {\r\n    const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/);\r\n    const context = {\r\n        // options\r\n        selfName: nameMatch && capitalize(camelize$1(nameMatch[1])),\r\n        prefixIdentifiers,\r\n        hoistStatic,\r\n        cacheHandlers,\r\n        nodeTransforms,\r\n        directiveTransforms,\r\n        transformHoist,\r\n        isBuiltInComponent,\r\n        isCustomElement,\r\n        expressionPlugins,\r\n        scopeId,\r\n        slotted,\r\n        ssr,\r\n        ssrCssVars,\r\n        bindingMetadata,\r\n        inline,\r\n        isTS,\r\n        onError,\r\n        // state\r\n        root,\r\n        helpers: new Map(),\r\n        components: new Set(),\r\n        directives: new Set(),\r\n        hoists: [],\r\n        imports: [],\r\n        constantCache: new Map(),\r\n        temps: 0,\r\n        cached: 0,\r\n        identifiers: Object.create(null),\r\n        scopes: {\r\n            vFor: 0,\r\n            vSlot: 0,\r\n            vPre: 0,\r\n            vOnce: 0\r\n        },\r\n        parent: null,\r\n        currentNode: root,\r\n        childIndex: 0,\r\n        // methods\r\n        helper(name) {\r\n            const count = context.helpers.get(name) || 0;\r\n            context.helpers.set(name, count + 1);\r\n            return name;\r\n        },\r\n        removeHelper(name) {\r\n            const count = context.helpers.get(name);\r\n            if (count) {\r\n                const currentCount = count - 1;\r\n                if (!currentCount) {\r\n                    context.helpers.delete(name);\r\n                }\r\n                else {\r\n                    context.helpers.set(name, currentCount);\r\n                }\r\n            }\r\n        },\r\n        helperString(name) {\r\n            return `_${helperNameMap[context.helper(name)]}`;\r\n        },\r\n        replaceNode(node) {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!context.currentNode) {\r\n                    throw new Error(`Node being replaced is already removed.`);\r\n                }\r\n                if (!context.parent) {\r\n                    throw new Error(`Cannot replace root node.`);\r\n                }\r\n            }\r\n            context.parent.children[context.childIndex] = context.currentNode = node;\r\n        },\r\n        removeNode(node) {\r\n            if ((process.env.NODE_ENV !== 'production') && !context.parent) {\r\n                throw new Error(`Cannot remove root node.`);\r\n            }\r\n            const list = context.parent.children;\r\n            const removalIndex = node\r\n                ? list.indexOf(node)\r\n                : context.currentNode\r\n                    ? context.childIndex\r\n                    : -1;\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && removalIndex < 0) {\r\n                throw new Error(`node being removed is not a child of current parent`);\r\n            }\r\n            if (!node || node === context.currentNode) {\r\n                // current node removed\r\n                context.currentNode = null;\r\n                context.onNodeRemoved();\r\n            }\r\n            else {\r\n                // sibling node removed\r\n                if (context.childIndex > removalIndex) {\r\n                    context.childIndex--;\r\n                    context.onNodeRemoved();\r\n                }\r\n            }\r\n            context.parent.children.splice(removalIndex, 1);\r\n        },\r\n        onNodeRemoved: () => { },\r\n        addIdentifiers(exp) {\r\n        },\r\n        removeIdentifiers(exp) {\r\n        },\r\n        hoist(exp) {\r\n            context.hoists.push(exp);\r\n            const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2 /* CAN_HOIST */);\r\n            identifier.hoisted = exp;\r\n            return identifier;\r\n        },\r\n        cache(exp, isVNode = false) {\r\n            return createCacheExpression(++context.cached, exp, isVNode);\r\n        }\r\n    };\r\n    return context;\r\n}\r\nfunction transform(root, options) {\r\n    const context = createTransformContext(root, options);\r\n    traverseNode(root, context);\r\n    if (options.hoistStatic) {\r\n        hoistStatic(root, context);\r\n    }\r\n    if (!options.ssr) {\r\n        createRootCodegen(root, context);\r\n    }\r\n    // finalize meta information\r\n    root.helpers = [...context.helpers.keys()];\r\n    root.components = [...context.components];\r\n    root.directives = [...context.directives];\r\n    root.imports = context.imports;\r\n    root.hoists = context.hoists;\r\n    root.temps = context.temps;\r\n    root.cached = context.cached;\r\n}\r\nfunction createRootCodegen(root, context) {\r\n    const { helper, removeHelper } = context;\r\n    const { children } = root;\r\n    if (children.length === 1) {\r\n        const child = children[0];\r\n        // if the single child is an element, turn it into a block.\r\n        if (isSingleElementRoot(root, child) && child.codegenNode) {\r\n            // single element root is never hoisted so codegenNode will never be\r\n            // SimpleExpressionNode\r\n            const codegenNode = child.codegenNode;\r\n            if (codegenNode.type === 13 /* VNODE_CALL */) {\r\n                if (!codegenNode.isBlock) {\r\n                    removeHelper(CREATE_VNODE);\r\n                    codegenNode.isBlock = true;\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n            }\r\n            root.codegenNode = codegenNode;\r\n        }\r\n        else {\r\n            // - single <slot/>, IfNode, ForNode: already blocks.\r\n            // - single text node: always patched.\r\n            // root codegen falls through via genNode()\r\n            root.codegenNode = child;\r\n        }\r\n    }\r\n    else if (children.length > 1) {\r\n        // root has multiple nodes - return a fragment block.\r\n        let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n        let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n        // check if the fragment actually contains a single valid child with\r\n        // the rest being comments\r\n        if ((process.env.NODE_ENV !== 'production') &&\r\n            children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {\r\n            patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;\r\n            patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;\r\n        }\r\n        root.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, root.children, patchFlag + ((process.env.NODE_ENV !== 'production') ? ` /* ${patchFlagText} */` : ``), undefined, undefined, true);\r\n    }\r\n    else ;\r\n}\r\nfunction traverseChildren(parent, context) {\r\n    let i = 0;\r\n    const nodeRemoved = () => {\r\n        i--;\r\n    };\r\n    for (; i < parent.children.length; i++) {\r\n        const child = parent.children[i];\r\n        if (isString(child))\r\n            continue;\r\n        context.parent = parent;\r\n        context.childIndex = i;\r\n        context.onNodeRemoved = nodeRemoved;\r\n        traverseNode(child, context);\r\n    }\r\n}\r\nfunction traverseNode(node, context) {\r\n    context.currentNode = node;\r\n    // apply transform plugins\r\n    const { nodeTransforms } = context;\r\n    const exitFns = [];\r\n    for (let i = 0; i < nodeTransforms.length; i++) {\r\n        const onExit = nodeTransforms[i](node, context);\r\n        if (onExit) {\r\n            if (isArray(onExit)) {\r\n                exitFns.push(...onExit);\r\n            }\r\n            else {\r\n                exitFns.push(onExit);\r\n            }\r\n        }\r\n        if (!context.currentNode) {\r\n            // node was removed\r\n            return;\r\n        }\r\n        else {\r\n            // node may have been replaced\r\n            node = context.currentNode;\r\n        }\r\n    }\r\n    switch (node.type) {\r\n        case 3 /* COMMENT */:\r\n            if (!context.ssr) {\r\n                // inject import for the Comment symbol, which is needed for creating\r\n                // comment nodes with `createVNode`\r\n                context.helper(CREATE_COMMENT);\r\n            }\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            // no need to traverse, but we need to inject toString helper\r\n            if (!context.ssr) {\r\n                context.helper(TO_DISPLAY_STRING);\r\n            }\r\n            break;\r\n        // for container types, further traverse downwards\r\n        case 9 /* IF */:\r\n            for (let i = 0; i < node.branches.length; i++) {\r\n                traverseNode(node.branches[i], context);\r\n            }\r\n            break;\r\n        case 10 /* IF_BRANCH */:\r\n        case 11 /* FOR */:\r\n        case 1 /* ELEMENT */:\r\n        case 0 /* ROOT */:\r\n            traverseChildren(node, context);\r\n            break;\r\n    }\r\n    // exit transforms\r\n    context.currentNode = node;\r\n    let i = exitFns.length;\r\n    while (i--) {\r\n        exitFns[i]();\r\n    }\r\n}\r\nfunction createStructuralDirectiveTransform(name, fn) {\r\n    const matches = isString(name)\r\n        ? (n) => n === name\r\n        : (n) => name.test(n);\r\n    return (node, context) => {\r\n        if (node.type === 1 /* ELEMENT */) {\r\n            const { props } = node;\r\n            // structural directive transforms are not concerned with slots\r\n            // as they are handled separately in vSlot.ts\r\n            if (node.tagType === 3 /* TEMPLATE */ && props.some(isVSlot)) {\r\n                return;\r\n            }\r\n            const exitFns = [];\r\n            for (let i = 0; i < props.length; i++) {\r\n                const prop = props[i];\r\n                if (prop.type === 7 /* DIRECTIVE */ && matches(prop.name)) {\r\n                    // structural directives are removed to avoid infinite recursion\r\n                    // also we remove them *before* applying so that it can further\r\n                    // traverse itself in case it moves the node around\r\n                    props.splice(i, 1);\r\n                    i--;\r\n                    const onExit = fn(node, prop, context);\r\n                    if (onExit)\r\n                        exitFns.push(onExit);\r\n                }\r\n            }\r\n            return exitFns;\r\n        }\r\n    };\r\n}\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`;\r\nfunction createCodegenContext(ast, { mode = 'function', prefixIdentifiers = mode === 'module', sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false }) {\r\n    const context = {\r\n        mode,\r\n        prefixIdentifiers,\r\n        sourceMap,\r\n        filename,\r\n        scopeId,\r\n        optimizeImports,\r\n        runtimeGlobalName,\r\n        runtimeModuleName,\r\n        ssr,\r\n        source: ast.loc.source,\r\n        code: ``,\r\n        column: 1,\r\n        line: 1,\r\n        offset: 0,\r\n        indentLevel: 0,\r\n        pure: false,\r\n        map: undefined,\r\n        helper(key) {\r\n            return `_${helperNameMap[key]}`;\r\n        },\r\n        push(code, node) {\r\n            context.code += code;\r\n        },\r\n        indent() {\r\n            newline(++context.indentLevel);\r\n        },\r\n        deindent(withoutNewLine = false) {\r\n            if (withoutNewLine) {\r\n                --context.indentLevel;\r\n            }\r\n            else {\r\n                newline(--context.indentLevel);\r\n            }\r\n        },\r\n        newline() {\r\n            newline(context.indentLevel);\r\n        }\r\n    };\r\n    function newline(n) {\r\n        context.push('\\n' + `  `.repeat(n));\r\n    }\r\n    return context;\r\n}\r\nfunction generate(ast, options = {}) {\r\n    const context = createCodegenContext(ast, options);\r\n    if (options.onContextCreated)\r\n        options.onContextCreated(context);\r\n    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;\r\n    const hasHelpers = ast.helpers.length > 0;\r\n    const useWithBlock = !prefixIdentifiers && mode !== 'module';\r\n    // preambles\r\n    // in setup() inline mode, the preamble is generated in a sub context\r\n    // and returned separately.\r\n    const preambleContext = context;\r\n    {\r\n        genFunctionPreamble(ast, preambleContext);\r\n    }\r\n    // enter render function\r\n    const functionName = ssr ? `ssrRender` : `render`;\r\n    const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache'];\r\n    const signature = args.join(', ');\r\n    {\r\n        push(`function ${functionName}(${signature}) {`);\r\n    }\r\n    indent();\r\n    if (useWithBlock) {\r\n        push(`with (_ctx) {`);\r\n        indent();\r\n        // function mode const declarations should be inside with block\r\n        // also they should be renamed to avoid collision with user properties\r\n        if (hasHelpers) {\r\n            push(`const { ${ast.helpers\r\n                .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\r\n                .join(', ')} } = _Vue`);\r\n            push(`\\n`);\r\n            newline();\r\n        }\r\n    }\r\n    // generate asset resolution statements\r\n    if (ast.components.length) {\r\n        genAssets(ast.components, 'component', context);\r\n        if (ast.directives.length || ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.directives.length) {\r\n        genAssets(ast.directives, 'directive', context);\r\n        if (ast.temps > 0) {\r\n            newline();\r\n        }\r\n    }\r\n    if (ast.temps > 0) {\r\n        push(`let `);\r\n        for (let i = 0; i < ast.temps; i++) {\r\n            push(`${i > 0 ? `, ` : ``}_temp${i}`);\r\n        }\r\n    }\r\n    if (ast.components.length || ast.directives.length || ast.temps) {\r\n        push(`\\n`);\r\n        newline();\r\n    }\r\n    // generate the VNode tree expression\r\n    if (!ssr) {\r\n        push(`return `);\r\n    }\r\n    if (ast.codegenNode) {\r\n        genNode(ast.codegenNode, context);\r\n    }\r\n    else {\r\n        push(`null`);\r\n    }\r\n    if (useWithBlock) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    deindent();\r\n    push(`}`);\r\n    return {\r\n        ast,\r\n        code: context.code,\r\n        preamble: ``,\r\n        // SourceMapGenerator does have toJSON() method but it's not in the types\r\n        map: context.map ? context.map.toJSON() : undefined\r\n    };\r\n}\r\nfunction genFunctionPreamble(ast, context) {\r\n    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;\r\n    const VueBinding = runtimeGlobalName;\r\n    const aliasHelper = (s) => `${helperNameMap[s]}: _${helperNameMap[s]}`;\r\n    // Generate const declaration for helpers\r\n    // In prefix mode, we place the const declaration at top so it's done\r\n    // only once; But if we not prefixing, we place the declaration inside the\r\n    // with block so it doesn't incur the `in` check cost for every helper access.\r\n    if (ast.helpers.length > 0) {\r\n        {\r\n            // \"with\" mode.\r\n            // save Vue in a separate variable to avoid collision\r\n            push(`const _Vue = ${VueBinding}\\n`);\r\n            // in \"with\" mode, helpers are declared inside the with block to avoid\r\n            // has check cost, but hoists are lifted out of the function - we need\r\n            // to provide the helper here.\r\n            if (ast.hoists.length) {\r\n                const staticHelpers = [\r\n                    CREATE_VNODE,\r\n                    CREATE_COMMENT,\r\n                    CREATE_TEXT,\r\n                    CREATE_STATIC\r\n                ]\r\n                    .filter(helper => ast.helpers.includes(helper))\r\n                    .map(aliasHelper)\r\n                    .join(', ');\r\n                push(`const { ${staticHelpers} } = _Vue\\n`);\r\n            }\r\n        }\r\n    }\r\n    genHoists(ast.hoists, context);\r\n    newline();\r\n    push(`return `);\r\n}\r\nfunction genAssets(assets, type, { helper, push, newline }) {\r\n    const resolver = helper(type === 'component' ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);\r\n    for (let i = 0; i < assets.length; i++) {\r\n        let id = assets[i];\r\n        // potential component implicit self-reference inferred from SFC filename\r\n        const maybeSelfReference = id.endsWith('__self');\r\n        if (maybeSelfReference) {\r\n            id = id.slice(0, -6);\r\n        }\r\n        push(`const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${maybeSelfReference ? `, true` : ``})`);\r\n        if (i < assets.length - 1) {\r\n            newline();\r\n        }\r\n    }\r\n}\r\nfunction genHoists(hoists, context) {\r\n    if (!hoists.length) {\r\n        return;\r\n    }\r\n    context.pure = true;\r\n    const { push, newline, helper, scopeId, mode } = context;\r\n    newline();\r\n    hoists.forEach((exp, i) => {\r\n        if (exp) {\r\n            push(`const _hoisted_${i + 1} = `);\r\n            genNode(exp, context);\r\n            newline();\r\n        }\r\n    });\r\n    context.pure = false;\r\n}\r\nfunction isText$1(n) {\r\n    return (isString(n) ||\r\n        n.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n        n.type === 2 /* TEXT */ ||\r\n        n.type === 5 /* INTERPOLATION */ ||\r\n        n.type === 8 /* COMPOUND_EXPRESSION */);\r\n}\r\nfunction genNodeListAsArray(nodes, context) {\r\n    const multilines = nodes.length > 3 ||\r\n        (((process.env.NODE_ENV !== 'production')) && nodes.some(n => isArray(n) || !isText$1(n)));\r\n    context.push(`[`);\r\n    multilines && context.indent();\r\n    genNodeList(nodes, context, multilines);\r\n    multilines && context.deindent();\r\n    context.push(`]`);\r\n}\r\nfunction genNodeList(nodes, context, multilines = false, comma = true) {\r\n    const { push, newline } = context;\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        if (isString(node)) {\r\n            push(node);\r\n        }\r\n        else if (isArray(node)) {\r\n            genNodeListAsArray(node, context);\r\n        }\r\n        else {\r\n            genNode(node, context);\r\n        }\r\n        if (i < nodes.length - 1) {\r\n            if (multilines) {\r\n                comma && push(',');\r\n                newline();\r\n            }\r\n            else {\r\n                comma && push(', ');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction genNode(node, context) {\r\n    if (isString(node)) {\r\n        context.push(node);\r\n        return;\r\n    }\r\n    if (isSymbol(node)) {\r\n        context.push(context.helper(node));\r\n        return;\r\n    }\r\n    switch (node.type) {\r\n        case 1 /* ELEMENT */:\r\n        case 9 /* IF */:\r\n        case 11 /* FOR */:\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. ` +\r\n                    `Apply appropriate transforms first.`);\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 2 /* TEXT */:\r\n            genText(node, context);\r\n            break;\r\n        case 4 /* SIMPLE_EXPRESSION */:\r\n            genExpression(node, context);\r\n            break;\r\n        case 5 /* INTERPOLATION */:\r\n            genInterpolation(node, context);\r\n            break;\r\n        case 12 /* TEXT_CALL */:\r\n            genNode(node.codegenNode, context);\r\n            break;\r\n        case 8 /* COMPOUND_EXPRESSION */:\r\n            genCompoundExpression(node, context);\r\n            break;\r\n        case 3 /* COMMENT */:\r\n            genComment(node, context);\r\n            break;\r\n        case 13 /* VNODE_CALL */:\r\n            genVNodeCall(node, context);\r\n            break;\r\n        case 14 /* JS_CALL_EXPRESSION */:\r\n            genCallExpression(node, context);\r\n            break;\r\n        case 15 /* JS_OBJECT_EXPRESSION */:\r\n            genObjectExpression(node, context);\r\n            break;\r\n        case 17 /* JS_ARRAY_EXPRESSION */:\r\n            genArrayExpression(node, context);\r\n            break;\r\n        case 18 /* JS_FUNCTION_EXPRESSION */:\r\n            genFunctionExpression(node, context);\r\n            break;\r\n        case 19 /* JS_CONDITIONAL_EXPRESSION */:\r\n            genConditionalExpression(node, context);\r\n            break;\r\n        case 20 /* JS_CACHE_EXPRESSION */:\r\n            genCacheExpression(node, context);\r\n            break;\r\n        // SSR only types\r\n        case 21 /* JS_BLOCK_STATEMENT */:\r\n            break;\r\n        case 22 /* JS_TEMPLATE_LITERAL */:\r\n            break;\r\n        case 23 /* JS_IF_STATEMENT */:\r\n            break;\r\n        case 24 /* JS_ASSIGNMENT_EXPRESSION */:\r\n            break;\r\n        case 25 /* JS_SEQUENCE_EXPRESSION */:\r\n            break;\r\n        case 26 /* JS_RETURN_STATEMENT */:\r\n            break;\r\n        /* istanbul ignore next */\r\n        case 10 /* IF_BRANCH */:\r\n            // noop\r\n            break;\r\n        default:\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                assert(false, `unhandled codegen node type: ${node.type}`);\r\n                // make sure we exhaust all possible types\r\n                const exhaustiveCheck = node;\r\n                return exhaustiveCheck;\r\n            }\r\n    }\r\n}\r\nfunction genText(node, context) {\r\n    context.push(JSON.stringify(node.content), node);\r\n}\r\nfunction genExpression(node, context) {\r\n    const { content, isStatic } = node;\r\n    context.push(isStatic ? JSON.stringify(content) : content, node);\r\n}\r\nfunction genInterpolation(node, context) {\r\n    const { push, helper, pure } = context;\r\n    if (pure)\r\n        push(PURE_ANNOTATION);\r\n    push(`${helper(TO_DISPLAY_STRING)}(`);\r\n    genNode(node.content, context);\r\n    push(`)`);\r\n}\r\nfunction genCompoundExpression(node, context) {\r\n    for (let i = 0; i < node.children.length; i++) {\r\n        const child = node.children[i];\r\n        if (isString(child)) {\r\n            context.push(child);\r\n        }\r\n        else {\r\n            genNode(child, context);\r\n        }\r\n    }\r\n}\r\nfunction genExpressionAsPropertyKey(node, context) {\r\n    const { push } = context;\r\n    if (node.type === 8 /* COMPOUND_EXPRESSION */) {\r\n        push(`[`);\r\n        genCompoundExpression(node, context);\r\n        push(`]`);\r\n    }\r\n    else if (node.isStatic) {\r\n        // only quote keys if necessary\r\n        const text = isSimpleIdentifier(node.content)\r\n            ? node.content\r\n            : JSON.stringify(node.content);\r\n        push(text, node);\r\n    }\r\n    else {\r\n        push(`[${node.content}]`, node);\r\n    }\r\n}\r\nfunction genComment(node, context) {\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const { push, helper, pure } = context;\r\n        if (pure) {\r\n            push(PURE_ANNOTATION);\r\n        }\r\n        push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);\r\n    }\r\n}\r\nfunction genVNodeCall(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const { tag, props, children, patchFlag, dynamicProps, directives, isBlock, disableTracking } = node;\r\n    if (directives) {\r\n        push(helper(WITH_DIRECTIVES) + `(`);\r\n    }\r\n    if (isBlock) {\r\n        push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);\r\n    }\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(helper(isBlock ? CREATE_BLOCK : CREATE_VNODE) + `(`, node);\r\n    genNodeList(genNullableArgs([tag, props, children, patchFlag, dynamicProps]), context);\r\n    push(`)`);\r\n    if (isBlock) {\r\n        push(`)`);\r\n    }\r\n    if (directives) {\r\n        push(`, `);\r\n        genNode(directives, context);\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genNullableArgs(args) {\r\n    let i = args.length;\r\n    while (i--) {\r\n        if (args[i] != null)\r\n            break;\r\n    }\r\n    return args.slice(0, i + 1).map(arg => arg || `null`);\r\n}\r\n// JavaScript\r\nfunction genCallExpression(node, context) {\r\n    const { push, helper, pure } = context;\r\n    const callee = isString(node.callee) ? node.callee : helper(node.callee);\r\n    if (pure) {\r\n        push(PURE_ANNOTATION);\r\n    }\r\n    push(callee + `(`, node);\r\n    genNodeList(node.arguments, context);\r\n    push(`)`);\r\n}\r\nfunction genObjectExpression(node, context) {\r\n    const { push, indent, deindent, newline } = context;\r\n    const { properties } = node;\r\n    if (!properties.length) {\r\n        push(`{}`, node);\r\n        return;\r\n    }\r\n    const multilines = properties.length > 1 ||\r\n        (((process.env.NODE_ENV !== 'production')) &&\r\n            properties.some(p => p.value.type !== 4 /* SIMPLE_EXPRESSION */));\r\n    push(multilines ? `{` : `{ `);\r\n    multilines && indent();\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const { key, value } = properties[i];\r\n        // key\r\n        genExpressionAsPropertyKey(key, context);\r\n        push(`: `);\r\n        // value\r\n        genNode(value, context);\r\n        if (i < properties.length - 1) {\r\n            // will only reach this if it's multilines\r\n            push(`,`);\r\n            newline();\r\n        }\r\n    }\r\n    multilines && deindent();\r\n    push(multilines ? `}` : ` }`);\r\n}\r\nfunction genArrayExpression(node, context) {\r\n    genNodeListAsArray(node.elements, context);\r\n}\r\nfunction genFunctionExpression(node, context) {\r\n    const { push, indent, deindent, scopeId, mode } = context;\r\n    const { params, returns, body, newline, isSlot } = node;\r\n    if (isSlot) {\r\n        // wrap slot functions with owner context\r\n        push(`_${helperNameMap[WITH_CTX]}(`);\r\n    }\r\n    push(`(`, node);\r\n    if (isArray(params)) {\r\n        genNodeList(params, context);\r\n    }\r\n    else if (params) {\r\n        genNode(params, context);\r\n    }\r\n    push(`) => `);\r\n    if (newline || body) {\r\n        push(`{`);\r\n        indent();\r\n    }\r\n    if (returns) {\r\n        if (newline) {\r\n            push(`return `);\r\n        }\r\n        if (isArray(returns)) {\r\n            genNodeListAsArray(returns, context);\r\n        }\r\n        else {\r\n            genNode(returns, context);\r\n        }\r\n    }\r\n    else if (body) {\r\n        genNode(body, context);\r\n    }\r\n    if (newline || body) {\r\n        deindent();\r\n        push(`}`);\r\n    }\r\n    if (isSlot) {\r\n        push(`)`);\r\n    }\r\n}\r\nfunction genConditionalExpression(node, context) {\r\n    const { test, consequent, alternate, newline: needNewline } = node;\r\n    const { push, indent, deindent, newline } = context;\r\n    if (test.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        const needsParens = !isSimpleIdentifier(test.content);\r\n        needsParens && push(`(`);\r\n        genExpression(test, context);\r\n        needsParens && push(`)`);\r\n    }\r\n    else {\r\n        push(`(`);\r\n        genNode(test, context);\r\n        push(`)`);\r\n    }\r\n    needNewline && indent();\r\n    context.indentLevel++;\r\n    needNewline || push(` `);\r\n    push(`? `);\r\n    genNode(consequent, context);\r\n    context.indentLevel--;\r\n    needNewline && newline();\r\n    needNewline || push(` `);\r\n    push(`: `);\r\n    const isNested = alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */;\r\n    if (!isNested) {\r\n        context.indentLevel++;\r\n    }\r\n    genNode(alternate, context);\r\n    if (!isNested) {\r\n        context.indentLevel--;\r\n    }\r\n    needNewline && deindent(true /* without newline */);\r\n}\r\nfunction genCacheExpression(node, context) {\r\n    const { push, helper, indent, deindent, newline } = context;\r\n    push(`_cache[${node.index}] || (`);\r\n    if (node.isVNode) {\r\n        indent();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(-1),`);\r\n        newline();\r\n    }\r\n    push(`_cache[${node.index}] = `);\r\n    genNode(node.value, context);\r\n    if (node.isVNode) {\r\n        push(`,`);\r\n        newline();\r\n        push(`${helper(SET_BLOCK_TRACKING)}(1),`);\r\n        newline();\r\n        push(`_cache[${node.index}]`);\r\n        deindent();\r\n    }\r\n    push(`)`);\r\n}\n\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nconst prohibitedKeywordRE = new RegExp('\\\\b' +\r\n    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\r\n        'super,throw,while,yield,delete,export,import,return,switch,default,' +\r\n        'extends,finally,continue,debugger,function,arguments,typeof,void')\r\n        .split(',')\r\n        .join('\\\\b|\\\\b') +\r\n    '\\\\b');\r\n// strip strings in expressions\r\nconst stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n/**\r\n * Validate a non-prefixed expression.\r\n * This is only called when using the in-browser runtime compiler since it\r\n * doesn't prefix expressions.\r\n */\r\nfunction validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {\r\n    const exp = node.content;\r\n    // empty expressions are validated per-directive since some directives\r\n    // do allow empty expressions.\r\n    if (!exp.trim()) {\r\n        return;\r\n    }\r\n    try {\r\n        new Function(asRawStatements\r\n            ? ` ${exp} `\r\n            : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);\r\n    }\r\n    catch (e) {\r\n        let message = e.message;\r\n        const keywordMatch = exp\r\n            .replace(stripStringRE, '')\r\n            .match(prohibitedKeywordRE);\r\n        if (keywordMatch) {\r\n            message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`;\r\n        }\r\n        context.onError(createCompilerError(43 /* X_INVALID_EXPRESSION */, node.loc, undefined, message));\r\n    }\r\n}\n\nconst transformExpression = (node, context) => {\r\n    if (node.type === 5 /* INTERPOLATION */) {\r\n        node.content = processExpression(node.content, context);\r\n    }\r\n    else if (node.type === 1 /* ELEMENT */) {\r\n        // handle directives on element\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const dir = node.props[i];\r\n            // do not process for v-on & v-for since they are special handled\r\n            if (dir.type === 7 /* DIRECTIVE */ && dir.name !== 'for') {\r\n                const exp = dir.exp;\r\n                const arg = dir.arg;\r\n                // do not process exp if this is v-on:arg - we need special handling\r\n                // for wrapping inline statements.\r\n                if (exp &&\r\n                    exp.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n                    !(dir.name === 'on' && arg)) {\r\n                    dir.exp = processExpression(exp, context, \r\n                    // slot args must be processed as function params\r\n                    dir.name === 'slot');\r\n                }\r\n                if (arg && arg.type === 4 /* SIMPLE_EXPRESSION */ && !arg.isStatic) {\r\n                    dir.arg = processExpression(arg, context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n// Important: since this function uses Node.js only dependencies, it should\r\n// always be used with a leading !true check so that it can be\r\n// tree-shaken from the browser build.\r\nfunction processExpression(node, context, \r\n// some expressions like v-slot props & v-for aliases should be parsed as\r\n// function params\r\nasParams = false, \r\n// v-on handler values may contain multiple statements\r\nasRawStatements = false) {\r\n    {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            // simple in-browser validation (same logic in 2.x)\r\n            validateBrowserExpression(node, context, asParams, asRawStatements);\r\n        }\r\n        return node;\r\n    }\r\n}\n\nconst transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {\r\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\r\n        // #1587: We need to dynamically increment the key based on the current\r\n        // node's sibling nodes, since chained v-if/else branches are\r\n        // rendered at the same depth\r\n        const siblings = context.parent.children;\r\n        let i = siblings.indexOf(ifNode);\r\n        let key = 0;\r\n        while (i-- >= 0) {\r\n            const sibling = siblings[i];\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                key += sibling.branches.length;\r\n            }\r\n        }\r\n        // Exit callback. Complete the codegenNode when all children have been\r\n        // transformed.\r\n        return () => {\r\n            if (isRoot) {\r\n                ifNode.codegenNode = createCodegenNodeForBranch(branch, key, context);\r\n            }\r\n            else {\r\n                // attach this branch's codegen node to the v-if root.\r\n                const parentCondition = getParentCondition(ifNode.codegenNode);\r\n                parentCondition.alternate = createCodegenNodeForBranch(branch, key + ifNode.branches.length - 1, context);\r\n            }\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processIf(node, dir, context, processCodegen) {\r\n    if (dir.name !== 'else' &&\r\n        (!dir.exp || !dir.exp.content.trim())) {\r\n        const loc = dir.exp ? dir.exp.loc : node.loc;\r\n        context.onError(createCompilerError(27 /* X_V_IF_NO_EXPRESSION */, dir.loc));\r\n        dir.exp = createSimpleExpression(`true`, false, loc);\r\n    }\r\n    if ((process.env.NODE_ENV !== 'production') && true && dir.exp) {\r\n        validateBrowserExpression(dir.exp, context);\r\n    }\r\n    if (dir.name === 'if') {\r\n        const branch = createIfBranch(node, dir);\r\n        const ifNode = {\r\n            type: 9 /* IF */,\r\n            loc: node.loc,\r\n            branches: [branch]\r\n        };\r\n        context.replaceNode(ifNode);\r\n        if (processCodegen) {\r\n            return processCodegen(ifNode, branch, true);\r\n        }\r\n    }\r\n    else {\r\n        // locate the adjacent v-if\r\n        const siblings = context.parent.children;\r\n        const comments = [];\r\n        let i = siblings.indexOf(node);\r\n        while (i-- >= -1) {\r\n            const sibling = siblings[i];\r\n            if ((process.env.NODE_ENV !== 'production') && sibling && sibling.type === 3 /* COMMENT */) {\r\n                context.removeNode(sibling);\r\n                comments.unshift(sibling);\r\n                continue;\r\n            }\r\n            if (sibling &&\r\n                sibling.type === 2 /* TEXT */ &&\r\n                !sibling.content.trim().length) {\r\n                context.removeNode(sibling);\r\n                continue;\r\n            }\r\n            if (sibling && sibling.type === 9 /* IF */) {\r\n                // move the node to the if node's branches\r\n                context.removeNode();\r\n                const branch = createIfBranch(node, dir);\r\n                if ((process.env.NODE_ENV !== 'production') && comments.length) {\r\n                    branch.children = [...comments, ...branch.children];\r\n                }\r\n                // check if user is forcing same key on different branches\r\n                if ((process.env.NODE_ENV !== 'production') || !true) {\r\n                    const key = branch.userKey;\r\n                    if (key) {\r\n                        sibling.branches.forEach(({ userKey }) => {\r\n                            if (isSameKey(userKey, key)) {\r\n                                context.onError(createCompilerError(28 /* X_V_IF_SAME_KEY */, branch.userKey.loc));\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n                sibling.branches.push(branch);\r\n                const onExit = processCodegen && processCodegen(sibling, branch, false);\r\n                // since the branch was removed, it will not be traversed.\r\n                // make sure to traverse here.\r\n                traverseNode(branch, context);\r\n                // call on exit\r\n                if (onExit)\r\n                    onExit();\r\n                // make sure to reset currentNode after traversal to indicate this\r\n                // node has been removed.\r\n                context.currentNode = null;\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, node.loc));\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction createIfBranch(node, dir) {\r\n    return {\r\n        type: 10 /* IF_BRANCH */,\r\n        loc: node.loc,\r\n        condition: dir.name === 'else' ? undefined : dir.exp,\r\n        children: node.tagType === 3 /* TEMPLATE */ && !findDir(node, 'for')\r\n            ? node.children\r\n            : [node],\r\n        userKey: findProp(node, `key`)\r\n    };\r\n}\r\nfunction createCodegenNodeForBranch(branch, keyIndex, context) {\r\n    if (branch.condition) {\r\n        return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), \r\n        // make sure to pass in asBlock: true so that the comment node call\r\n        // closes the current block.\r\n        createCallExpression(context.helper(CREATE_COMMENT), [\r\n            (process.env.NODE_ENV !== 'production') ? '\"v-if\"' : '\"\"',\r\n            'true'\r\n        ]));\r\n    }\r\n    else {\r\n        return createChildrenCodegenNode(branch, keyIndex, context);\r\n    }\r\n}\r\nfunction createChildrenCodegenNode(branch, keyIndex, context) {\r\n    const { helper, removeHelper } = context;\r\n    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2 /* CAN_HOIST */));\r\n    const { children } = branch;\r\n    const firstChild = children[0];\r\n    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1 /* ELEMENT */;\r\n    if (needFragmentWrapper) {\r\n        if (children.length === 1 && firstChild.type === 11 /* FOR */) {\r\n            // optimize away nested fragments when child is a ForNode\r\n            const vnodeCall = firstChild.codegenNode;\r\n            injectProp(vnodeCall, keyProperty, context);\r\n            return vnodeCall;\r\n        }\r\n        else {\r\n            let patchFlag = 64 /* STABLE_FRAGMENT */;\r\n            let patchFlagText = PatchFlagNames[64 /* STABLE_FRAGMENT */];\r\n            // check if the fragment actually contains a single valid child with\r\n            // the rest being comments\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                children.filter(c => c.type !== 3 /* COMMENT */).length === 1) {\r\n                patchFlag |= 2048 /* DEV_ROOT_FRAGMENT */;\r\n                patchFlagText += `, ${PatchFlagNames[2048 /* DEV_ROOT_FRAGMENT */]}`;\r\n            }\r\n            return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + ((process.env.NODE_ENV !== 'production') ? ` /* ${patchFlagText} */` : ``), undefined, undefined, true, false, branch.loc);\r\n        }\r\n    }\r\n    else {\r\n        const vnodeCall = firstChild\r\n            .codegenNode;\r\n        // Change createVNode to createBlock.\r\n        if (vnodeCall.type === 13 /* VNODE_CALL */ && !vnodeCall.isBlock) {\r\n            removeHelper(CREATE_VNODE);\r\n            vnodeCall.isBlock = true;\r\n            helper(OPEN_BLOCK);\r\n            helper(CREATE_BLOCK);\r\n        }\r\n        // inject branch key\r\n        injectProp(vnodeCall, keyProperty, context);\r\n        return vnodeCall;\r\n    }\r\n}\r\nfunction isSameKey(a, b) {\r\n    if (!a || a.type !== b.type) {\r\n        return false;\r\n    }\r\n    if (a.type === 6 /* ATTRIBUTE */) {\r\n        if (a.value.content !== b.value.content) {\r\n            return false;\r\n        }\r\n    }\r\n    else {\r\n        // directive\r\n        const exp = a.exp;\r\n        const branchExp = b.exp;\r\n        if (exp.type !== branchExp.type) {\r\n            return false;\r\n        }\r\n        if (exp.type !== 4 /* SIMPLE_EXPRESSION */ ||\r\n            (exp.isStatic !== branchExp.isStatic ||\r\n                exp.content !== branchExp.content)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getParentCondition(node) {\r\n    while (true) {\r\n        if (node.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n            if (node.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                node = node.alternate;\r\n            }\r\n            else {\r\n                return node;\r\n            }\r\n        }\r\n        else if (node.type === 20 /* JS_CACHE_EXPRESSION */) {\r\n            node = node.value;\r\n        }\r\n    }\r\n}\n\nconst transformFor = createStructuralDirectiveTransform('for', (node, dir, context) => {\r\n    const { helper, removeHelper } = context;\r\n    return processFor(node, dir, context, forNode => {\r\n        // create the loop render function expression now, and add the\r\n        // iterator on exit after all children have been traversed\r\n        const renderExp = createCallExpression(helper(RENDER_LIST), [\r\n            forNode.source\r\n        ]);\r\n        const keyProp = findProp(node, `key`);\r\n        const keyProperty = keyProp\r\n            ? createObjectProperty(`key`, keyProp.type === 6 /* ATTRIBUTE */\r\n                ? createSimpleExpression(keyProp.value.content, true)\r\n                : keyProp.exp)\r\n            : null;\r\n        const isStableFragment = forNode.source.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n            forNode.source.constType > 0 /* NOT_CONSTANT */;\r\n        const fragmentFlag = isStableFragment\r\n            ? 64 /* STABLE_FRAGMENT */\r\n            : keyProp\r\n                ? 128 /* KEYED_FRAGMENT */\r\n                : 256 /* UNKEYED_FRAGMENT */;\r\n        forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), undefined, renderExp, fragmentFlag +\r\n            ((process.env.NODE_ENV !== 'production') ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), undefined, undefined, true /* isBlock */, !isStableFragment /* disableTracking */, node.loc);\r\n        return () => {\r\n            // finish the codegen now that all children have been traversed\r\n            let childBlock;\r\n            const isTemplate = isTemplateNode(node);\r\n            const { children } = forNode;\r\n            // check <template v-for> key placement\r\n            if (((process.env.NODE_ENV !== 'production') || !true) && isTemplate) {\r\n                node.children.some(c => {\r\n                    if (c.type === 1 /* ELEMENT */) {\r\n                        const key = findProp(c, 'key');\r\n                        if (key) {\r\n                            context.onError(createCompilerError(32 /* X_V_FOR_TEMPLATE_KEY_PLACEMENT */, key.loc));\r\n                            return true;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1 /* ELEMENT */;\r\n            const slotOutlet = isSlotOutlet(node)\r\n                ? node\r\n                : isTemplate &&\r\n                    node.children.length === 1 &&\r\n                    isSlotOutlet(node.children[0])\r\n                    ? node.children[0] // api-extractor somehow fails to infer this\r\n                    : null;\r\n            if (slotOutlet) {\r\n                // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\r\n                childBlock = slotOutlet.codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    // <template v-for=\"...\" :key=\"...\"><slot/></template>\r\n                    // we need to inject the key to the renderSlot() call.\r\n                    // the props for renderSlot is passed as the 3rd argument.\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n            }\r\n            else if (needFragmentWrapper) {\r\n                // <template v-for=\"...\"> with text or multi-elements\r\n                // should generate a fragment block for each loop\r\n                childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : undefined, node.children, 64 /* STABLE_FRAGMENT */ +\r\n                    ((process.env.NODE_ENV !== 'production')\r\n                        ? ` /* ${PatchFlagNames[64 /* STABLE_FRAGMENT */]} */`\r\n                        : ``), undefined, undefined, true);\r\n            }\r\n            else {\r\n                // Normal element v-for. Directly use the child's codegenNode\r\n                // but mark it as a block.\r\n                childBlock = children[0]\r\n                    .codegenNode;\r\n                if (isTemplate && keyProperty) {\r\n                    injectProp(childBlock, keyProperty, context);\r\n                }\r\n                if (childBlock.isBlock !== !isStableFragment) {\r\n                    if (childBlock.isBlock) {\r\n                        // switch from block to vnode\r\n                        removeHelper(OPEN_BLOCK);\r\n                        removeHelper(CREATE_BLOCK);\r\n                    }\r\n                    else {\r\n                        // switch from vnode to block\r\n                        removeHelper(CREATE_VNODE);\r\n                    }\r\n                }\r\n                childBlock.isBlock = !isStableFragment;\r\n                if (childBlock.isBlock) {\r\n                    helper(OPEN_BLOCK);\r\n                    helper(CREATE_BLOCK);\r\n                }\r\n                else {\r\n                    helper(CREATE_VNODE);\r\n                }\r\n            }\r\n            renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true /* force newline */));\r\n        };\r\n    });\r\n});\r\n// target-agnostic transform used for both Client and SSR\r\nfunction processFor(node, dir, context, processCodegen) {\r\n    if (!dir.exp) {\r\n        context.onError(createCompilerError(30 /* X_V_FOR_NO_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const parseResult = parseForExpression(\r\n    // can only be simple expression because vFor transform is applied\r\n    // before expression transform.\r\n    dir.exp, context);\r\n    if (!parseResult) {\r\n        context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, dir.loc));\r\n        return;\r\n    }\r\n    const { addIdentifiers, removeIdentifiers, scopes } = context;\r\n    const { source, value, key, index } = parseResult;\r\n    const forNode = {\r\n        type: 11 /* FOR */,\r\n        loc: dir.loc,\r\n        source,\r\n        valueAlias: value,\r\n        keyAlias: key,\r\n        objectIndexAlias: index,\r\n        parseResult,\r\n        children: isTemplateNode(node) ? node.children : [node]\r\n    };\r\n    context.replaceNode(forNode);\r\n    // bookkeeping\r\n    scopes.vFor++;\r\n    const onExit = processCodegen && processCodegen(forNode);\r\n    return () => {\r\n        scopes.vFor--;\r\n        if (onExit)\r\n            onExit();\r\n    };\r\n}\r\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\n// This regex doesn't cover the case if key or index aliases have destructuring,\r\n// but those do not make sense in the first place, so this works in practice.\r\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nconst stripParensRE = /^\\(|\\)$/g;\r\nfunction parseForExpression(input, context) {\r\n    const loc = input.loc;\r\n    const exp = input.content;\r\n    const inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    const [, LHS, RHS] = inMatch;\r\n    const result = {\r\n        source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),\r\n        value: undefined,\r\n        key: undefined,\r\n        index: undefined\r\n    };\r\n    if ((process.env.NODE_ENV !== 'production') && true) {\r\n        validateBrowserExpression(result.source, context);\r\n    }\r\n    let valueContent = LHS.trim()\r\n        .replace(stripParensRE, '')\r\n        .trim();\r\n    const trimmedOffset = LHS.indexOf(valueContent);\r\n    const iteratorMatch = valueContent.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        valueContent = valueContent.replace(forIteratorRE, '').trim();\r\n        const keyContent = iteratorMatch[1].trim();\r\n        let keyOffset;\r\n        if (keyContent) {\r\n            keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);\r\n            result.key = createAliasExpression(loc, keyContent, keyOffset);\r\n            if ((process.env.NODE_ENV !== 'production') && true) {\r\n                validateBrowserExpression(result.key, context, true);\r\n            }\r\n        }\r\n        if (iteratorMatch[2]) {\r\n            const indexContent = iteratorMatch[2].trim();\r\n            if (indexContent) {\r\n                result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key\r\n                    ? keyOffset + keyContent.length\r\n                    : trimmedOffset + valueContent.length));\r\n                if ((process.env.NODE_ENV !== 'production') && true) {\r\n                    validateBrowserExpression(result.index, context, true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (valueContent) {\r\n        result.value = createAliasExpression(loc, valueContent, trimmedOffset);\r\n        if ((process.env.NODE_ENV !== 'production') && true) {\r\n            validateBrowserExpression(result.value, context, true);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction createAliasExpression(range, content, offset) {\r\n    return createSimpleExpression(content, false, getInnerRange(range, offset, content.length));\r\n}\r\nfunction createForLoopParams({ value, key, index }) {\r\n    const params = [];\r\n    if (value) {\r\n        params.push(value);\r\n    }\r\n    if (key) {\r\n        if (!value) {\r\n            params.push(createSimpleExpression(`_`, false));\r\n        }\r\n        params.push(key);\r\n    }\r\n    if (index) {\r\n        if (!key) {\r\n            if (!value) {\r\n                params.push(createSimpleExpression(`_`, false));\r\n            }\r\n            params.push(createSimpleExpression(`__`, false));\r\n        }\r\n        params.push(index);\r\n    }\r\n    return params;\r\n}\n\nconst defaultFallback = createSimpleExpression(`undefined`, false);\r\n// A NodeTransform that:\r\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\r\n//    by transformExpression. This is only applied in non-browser builds with\r\n//    { prefixIdentifiers: true }.\r\n// 2. Track v-slot depths so that we know a slot is inside another slot.\r\n//    Note the exit callback is executed before buildSlots() on the same node,\r\n//    so only nested slots see positive numbers.\r\nconst trackSlotScopes = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 1 /* COMPONENT */ ||\r\n            node.tagType === 3 /* TEMPLATE */)) {\r\n        // We are only checking non-empty v-slot here\r\n        // since we only care about slots that introduce scope variables.\r\n        const vSlot = findDir(node, 'slot');\r\n        if (vSlot) {\r\n            vSlot.exp;\r\n            context.scopes.vSlot++;\r\n            return () => {\r\n                context.scopes.vSlot--;\r\n            };\r\n        }\r\n    }\r\n};\r\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\r\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\r\nconst trackVForSlotScopes = (node, context) => {\r\n    let vFor;\r\n    if (isTemplateNode(node) &&\r\n        node.props.some(isVSlot) &&\r\n        (vFor = findDir(node, 'for'))) {\r\n        const result = (vFor.parseResult = parseForExpression(vFor.exp, context));\r\n        if (result) {\r\n            const { value, key, index } = result;\r\n            const { addIdentifiers, removeIdentifiers } = context;\r\n            value && addIdentifiers(value);\r\n            key && addIdentifiers(key);\r\n            index && addIdentifiers(index);\r\n            return () => {\r\n                value && removeIdentifiers(value);\r\n                key && removeIdentifiers(key);\r\n                index && removeIdentifiers(index);\r\n            };\r\n        }\r\n    }\r\n};\r\nconst buildClientSlotFn = (props, children, loc) => createFunctionExpression(props, children, false /* newline */, true /* isSlot */, children.length ? children[0].loc : loc);\r\n// Instead of being a DirectiveTransform, v-slot processing is called during\r\n// transformElement to build the slots object for a component.\r\nfunction buildSlots(node, context, buildSlotFn = buildClientSlotFn) {\r\n    context.helper(WITH_CTX);\r\n    const { children, loc } = node;\r\n    const slotsProperties = [];\r\n    const dynamicSlots = [];\r\n    const buildDefaultSlotProperty = (props, children) => createObjectProperty(`default`, buildSlotFn(props, children, loc));\r\n    // If the slot is inside a v-for or another v-slot, force it to be dynamic\r\n    // since it likely uses a scope variable.\r\n    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;\r\n    // 1. Check for slot with slotProps on component itself.\r\n    //    <Comp v-slot=\"{ prop }\"/>\r\n    const onComponentSlot = findDir(node, 'slot', true);\r\n    if (onComponentSlot) {\r\n        const { arg, exp } = onComponentSlot;\r\n        if (arg && !isStaticExp(arg)) {\r\n            hasDynamicSlots = true;\r\n        }\r\n        slotsProperties.push(createObjectProperty(arg || createSimpleExpression('default', true), buildSlotFn(exp, children, loc)));\r\n    }\r\n    // 2. Iterate through children and check for template slots\r\n    //    <template v-slot:foo=\"{ prop }\">\r\n    let hasTemplateSlots = false;\r\n    let hasNamedDefaultSlot = false;\r\n    const implicitDefaultChildren = [];\r\n    const seenSlotNames = new Set();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const slotElement = children[i];\r\n        let slotDir;\r\n        if (!isTemplateNode(slotElement) ||\r\n            !(slotDir = findDir(slotElement, 'slot', true))) {\r\n            // not a <template v-slot>, skip.\r\n            if (slotElement.type !== 3 /* COMMENT */) {\r\n                implicitDefaultChildren.push(slotElement);\r\n            }\r\n            continue;\r\n        }\r\n        if (onComponentSlot) {\r\n            // already has on-component slot - this is incorrect usage.\r\n            context.onError(createCompilerError(36 /* X_V_SLOT_MIXED_SLOT_USAGE */, slotDir.loc));\r\n            break;\r\n        }\r\n        hasTemplateSlots = true;\r\n        const { children: slotChildren, loc: slotLoc } = slotElement;\r\n        const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;\r\n        // check if name is dynamic.\r\n        let staticSlotName;\r\n        if (isStaticExp(slotName)) {\r\n            staticSlotName = slotName ? slotName.content : `default`;\r\n        }\r\n        else {\r\n            hasDynamicSlots = true;\r\n        }\r\n        const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);\r\n        // check if this slot is conditional (v-if/v-for)\r\n        let vIf;\r\n        let vElse;\r\n        let vFor;\r\n        if ((vIf = findDir(slotElement, 'if'))) {\r\n            hasDynamicSlots = true;\r\n            dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));\r\n        }\r\n        else if ((vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))) {\r\n            // find adjacent v-if\r\n            let j = i;\r\n            let prev;\r\n            while (j--) {\r\n                prev = children[j];\r\n                if (prev.type !== 3 /* COMMENT */) {\r\n                    break;\r\n                }\r\n            }\r\n            if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\r\n                // remove node\r\n                children.splice(i, 1);\r\n                i--;\r\n                // attach this slot to previous conditional\r\n                let conditional = dynamicSlots[dynamicSlots.length - 1];\r\n                while (conditional.alternate.type === 19 /* JS_CONDITIONAL_EXPRESSION */) {\r\n                    conditional = conditional.alternate;\r\n                }\r\n                conditional.alternate = vElse.exp\r\n                    ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback)\r\n                    : buildDynamicSlot(slotName, slotFunction);\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(29 /* X_V_ELSE_NO_ADJACENT_IF */, vElse.loc));\r\n            }\r\n        }\r\n        else if ((vFor = findDir(slotElement, 'for'))) {\r\n            hasDynamicSlots = true;\r\n            const parseResult = vFor.parseResult ||\r\n                parseForExpression(vFor.exp, context);\r\n            if (parseResult) {\r\n                // Render the dynamic slots as an array and add it to the createSlot()\r\n                // args. The runtime knows how to handle it appropriately.\r\n                dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [\r\n                    parseResult.source,\r\n                    createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true /* force newline */)\r\n                ]));\r\n            }\r\n            else {\r\n                context.onError(createCompilerError(31 /* X_V_FOR_MALFORMED_EXPRESSION */, vFor.loc));\r\n            }\r\n        }\r\n        else {\r\n            // check duplicate static names\r\n            if (staticSlotName) {\r\n                if (seenSlotNames.has(staticSlotName)) {\r\n                    context.onError(createCompilerError(37 /* X_V_SLOT_DUPLICATE_SLOT_NAMES */, dirLoc));\r\n                    continue;\r\n                }\r\n                seenSlotNames.add(staticSlotName);\r\n                if (staticSlotName === 'default') {\r\n                    hasNamedDefaultSlot = true;\r\n                }\r\n            }\r\n            slotsProperties.push(createObjectProperty(slotName, slotFunction));\r\n        }\r\n    }\r\n    if (!onComponentSlot) {\r\n        if (!hasTemplateSlots) {\r\n            // implicit default slot (on component)\r\n            slotsProperties.push(buildDefaultSlotProperty(undefined, children));\r\n        }\r\n        else if (implicitDefaultChildren.length) {\r\n            // implicit default slot (mixed with named slots)\r\n            if (hasNamedDefaultSlot) {\r\n                context.onError(createCompilerError(38 /* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */, implicitDefaultChildren[0].loc));\r\n            }\r\n            else {\r\n                slotsProperties.push(buildDefaultSlotProperty(undefined, implicitDefaultChildren));\r\n            }\r\n        }\r\n    }\r\n    const slotFlag = hasDynamicSlots\r\n        ? 2 /* DYNAMIC */\r\n        : hasForwardedSlots(node.children)\r\n            ? 3 /* FORWARDED */\r\n            : 1 /* STABLE */;\r\n    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, \r\n    // 2 = compiled but dynamic = can skip normalization, but must run diff\r\n    // 1 = compiled and static = can skip normalization AND diff as optimized\r\n    createSimpleExpression(slotFlag + ((process.env.NODE_ENV !== 'production') ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);\r\n    if (dynamicSlots.length) {\r\n        slots = createCallExpression(context.helper(CREATE_SLOTS), [\r\n            slots,\r\n            createArrayExpression(dynamicSlots)\r\n        ]);\r\n    }\r\n    return {\r\n        slots,\r\n        hasDynamicSlots\r\n    };\r\n}\r\nfunction buildDynamicSlot(name, fn) {\r\n    return createObjectExpression([\r\n        createObjectProperty(`name`, name),\r\n        createObjectProperty(`fn`, fn)\r\n    ]);\r\n}\r\nfunction hasForwardedSlots(children) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        switch (child.type) {\r\n            case 1 /* ELEMENT */:\r\n                if (child.tagType === 2 /* SLOT */ ||\r\n                    (child.tagType === 0 /* ELEMENT */ &&\r\n                        hasForwardedSlots(child.children))) {\r\n                    return true;\r\n                }\r\n                break;\r\n            case 9 /* IF */:\r\n                if (hasForwardedSlots(child.branches))\r\n                    return true;\r\n                break;\r\n            case 10 /* IF_BRANCH */:\r\n            case 11 /* FOR */:\r\n                if (hasForwardedSlots(child.children))\r\n                    return true;\r\n                break;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\r\n// import, which should be used instead of a resolveDirective call.\r\nconst directiveImportMap = new WeakMap();\r\n// generate a JavaScript AST for this element's codegen\r\nconst transformElement = (node, context) => {\r\n    // perform the work on exit, after all child expressions have been\r\n    // processed and merged.\r\n    return function postTransformElement() {\r\n        node = context.currentNode;\r\n        if (!(node.type === 1 /* ELEMENT */ &&\r\n            (node.tagType === 0 /* ELEMENT */ ||\r\n                node.tagType === 1 /* COMPONENT */))) {\r\n            return;\r\n        }\r\n        const { tag, props } = node;\r\n        const isComponent = node.tagType === 1 /* COMPONENT */;\r\n        // The goal of the transform is to create a codegenNode implementing the\r\n        // VNodeCall interface.\r\n        const vnodeTag = isComponent\r\n            ? resolveComponentType(node, context)\r\n            : `\"${tag}\"`;\r\n        const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;\r\n        let vnodeProps;\r\n        let vnodeChildren;\r\n        let vnodePatchFlag;\r\n        let patchFlag = 0;\r\n        let vnodeDynamicProps;\r\n        let dynamicPropNames;\r\n        let vnodeDirectives;\r\n        let shouldUseBlock = \r\n        // dynamic component may resolve to plain elements\r\n        isDynamicComponent ||\r\n            vnodeTag === TELEPORT ||\r\n            vnodeTag === SUSPENSE ||\r\n            (!isComponent &&\r\n                // <svg> and <foreignObject> must be forced into blocks so that block\r\n                // updates inside get proper isSVG flag at runtime. (#639, #643)\r\n                // This is technically web-specific, but splitting the logic out of core\r\n                // leads to too much unnecessary complexity.\r\n                (tag === 'svg' ||\r\n                    tag === 'foreignObject' ||\r\n                    // #938: elements with dynamic keys should be forced into blocks\r\n                    findProp(node, 'key', true)));\r\n        // props\r\n        if (props.length > 0) {\r\n            const propsBuildResult = buildProps(node, context);\r\n            vnodeProps = propsBuildResult.props;\r\n            patchFlag = propsBuildResult.patchFlag;\r\n            dynamicPropNames = propsBuildResult.dynamicPropNames;\r\n            const directives = propsBuildResult.directives;\r\n            vnodeDirectives =\r\n                directives && directives.length\r\n                    ? createArrayExpression(directives.map(dir => buildDirectiveArgs(dir, context)))\r\n                    : undefined;\r\n        }\r\n        // children\r\n        if (node.children.length > 0) {\r\n            if (vnodeTag === KEEP_ALIVE) {\r\n                // Although a built-in component, we compile KeepAlive with raw children\r\n                // instead of slot functions so that it can be used inside Transition\r\n                // or other Transition-wrapping HOCs.\r\n                // To ensure correct updates with block optimizations, we need to:\r\n                // 1. Force keep-alive into a block. This avoids its children being\r\n                //    collected by a parent block.\r\n                shouldUseBlock = true;\r\n                // 2. Force keep-alive to always be updated, since it uses raw children.\r\n                patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                if ((process.env.NODE_ENV !== 'production') && node.children.length > 1) {\r\n                    context.onError(createCompilerError(44 /* X_KEEP_ALIVE_INVALID_CHILDREN */, {\r\n                        start: node.children[0].loc.start,\r\n                        end: node.children[node.children.length - 1].loc.end,\r\n                        source: ''\r\n                    }));\r\n                }\r\n            }\r\n            const shouldBuildAsSlots = isComponent &&\r\n                // Teleport is not a real component and has dedicated runtime handling\r\n                vnodeTag !== TELEPORT &&\r\n                // explained above.\r\n                vnodeTag !== KEEP_ALIVE;\r\n            if (shouldBuildAsSlots) {\r\n                const { slots, hasDynamicSlots } = buildSlots(node, context);\r\n                vnodeChildren = slots;\r\n                if (hasDynamicSlots) {\r\n                    patchFlag |= 1024 /* DYNAMIC_SLOTS */;\r\n                }\r\n            }\r\n            else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\r\n                const child = node.children[0];\r\n                const type = child.type;\r\n                // check for dynamic text children\r\n                const hasDynamicTextChild = type === 5 /* INTERPOLATION */ ||\r\n                    type === 8 /* COMPOUND_EXPRESSION */;\r\n                if (hasDynamicTextChild &&\r\n                    getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                    patchFlag |= 1 /* TEXT */;\r\n                }\r\n                // pass directly if the only child is a text node\r\n                // (plain / interpolation / expression)\r\n                if (hasDynamicTextChild || type === 2 /* TEXT */) {\r\n                    vnodeChildren = child;\r\n                }\r\n                else {\r\n                    vnodeChildren = node.children;\r\n                }\r\n            }\r\n            else {\r\n                vnodeChildren = node.children;\r\n            }\r\n        }\r\n        // patchFlag & dynamicPropNames\r\n        if (patchFlag !== 0) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (patchFlag < 0) {\r\n                    // special flags (negative and mutually exclusive)\r\n                    vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;\r\n                }\r\n                else {\r\n                    // bitwise flags\r\n                    const flagNames = Object.keys(PatchFlagNames)\r\n                        .map(Number)\r\n                        .filter(n => n > 0 && patchFlag & n)\r\n                        .map(n => PatchFlagNames[n])\r\n                        .join(`, `);\r\n                    vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;\r\n                }\r\n            }\r\n            else {\r\n                vnodePatchFlag = String(patchFlag);\r\n            }\r\n            if (dynamicPropNames && dynamicPropNames.length) {\r\n                vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);\r\n            }\r\n        }\r\n        node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false /* disableTracking */, node.loc);\r\n    };\r\n};\r\nfunction resolveComponentType(node, context, ssr = false) {\r\n    const { tag } = node;\r\n    // 1. dynamic component\r\n    const isProp = isComponentTag(tag)\r\n        ? findProp(node, 'is')\r\n        : findDir(node, 'is');\r\n    if (isProp) {\r\n        const exp = isProp.type === 6 /* ATTRIBUTE */\r\n            ? isProp.value && createSimpleExpression(isProp.value.content, true)\r\n            : isProp.exp;\r\n        if (exp) {\r\n            return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\r\n                exp\r\n            ]);\r\n        }\r\n    }\r\n    // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\r\n    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);\r\n    if (builtIn) {\r\n        // built-ins are simply fallthroughs / have special handling during ssr\r\n        // so we don't need to import their runtime equivalents\r\n        if (!ssr)\r\n            context.helper(builtIn);\r\n        return builtIn;\r\n    }\r\n    // 5. user component (resolve)\r\n    context.helper(RESOLVE_COMPONENT);\r\n    context.components.add(tag);\r\n    return toValidAssetId(tag, `component`);\r\n}\r\nfunction buildProps(node, context, props = node.props, ssr = false) {\r\n    const { tag, loc: elementLoc } = node;\r\n    const isComponent = node.tagType === 1 /* COMPONENT */;\r\n    let properties = [];\r\n    const mergeArgs = [];\r\n    const runtimeDirectives = [];\r\n    // patchFlag analysis\r\n    let patchFlag = 0;\r\n    let hasRef = false;\r\n    let hasClassBinding = false;\r\n    let hasStyleBinding = false;\r\n    let hasHydrationEventBinding = false;\r\n    let hasDynamicKeys = false;\r\n    let hasVnodeHook = false;\r\n    const dynamicPropNames = [];\r\n    const analyzePatchFlag = ({ key, value }) => {\r\n        if (isStaticExp(key)) {\r\n            const name = key.content;\r\n            const isEventHandler = isOn(name);\r\n            if (!isComponent &&\r\n                isEventHandler &&\r\n                // omit the flag for click handlers because hydration gives click\r\n                // dedicated fast path.\r\n                name.toLowerCase() !== 'onclick' &&\r\n                // omit v-model handlers\r\n                name !== 'onUpdate:modelValue' &&\r\n                // omit onVnodeXXX hooks\r\n                !isReservedProp(name)) {\r\n                hasHydrationEventBinding = true;\r\n            }\r\n            if (isEventHandler && isReservedProp(name)) {\r\n                hasVnodeHook = true;\r\n            }\r\n            if (value.type === 20 /* JS_CACHE_EXPRESSION */ ||\r\n                ((value.type === 4 /* SIMPLE_EXPRESSION */ ||\r\n                    value.type === 8 /* COMPOUND_EXPRESSION */) &&\r\n                    getConstantType(value, context) > 0)) {\r\n                // skip if the prop is a cached handler or has constant value\r\n                return;\r\n            }\r\n            if (name === 'ref') {\r\n                hasRef = true;\r\n            }\r\n            else if (name === 'class' && !isComponent) {\r\n                hasClassBinding = true;\r\n            }\r\n            else if (name === 'style' && !isComponent) {\r\n                hasStyleBinding = true;\r\n            }\r\n            else if (name !== 'key' && !dynamicPropNames.includes(name)) {\r\n                dynamicPropNames.push(name);\r\n            }\r\n        }\r\n        else {\r\n            hasDynamicKeys = true;\r\n        }\r\n    };\r\n    for (let i = 0; i < props.length; i++) {\r\n        // static attribute\r\n        const prop = props[i];\r\n        if (prop.type === 6 /* ATTRIBUTE */) {\r\n            const { loc, name, value } = prop;\r\n            let isStatic = true;\r\n            if (name === 'ref') {\r\n                hasRef = true;\r\n            }\r\n            // skip :is on <component>\r\n            if (name === 'is' && isComponentTag(tag)) {\r\n                continue;\r\n            }\r\n            properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), createSimpleExpression(value ? value.content : '', isStatic, value ? value.loc : loc)));\r\n        }\r\n        else {\r\n            // directives\r\n            const { name, arg, exp, loc } = prop;\r\n            const isBind = name === 'bind';\r\n            const isOn = name === 'on';\r\n            // skip v-slot - it is handled by its dedicated transform.\r\n            if (name === 'slot') {\r\n                if (!isComponent) {\r\n                    context.onError(createCompilerError(39 /* X_V_SLOT_MISPLACED */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            // skip v-once - it is handled by its dedicated transform.\r\n            if (name === 'once') {\r\n                continue;\r\n            }\r\n            // skip v-is and :is on <component>\r\n            if (name === 'is' ||\r\n                (isBind && isComponentTag(tag) && isBindKey(arg, 'is'))) {\r\n                continue;\r\n            }\r\n            // skip v-on in SSR compilation\r\n            if (isOn && ssr) {\r\n                continue;\r\n            }\r\n            // special case for v-bind and v-on with no argument\r\n            if (!arg && (isBind || isOn)) {\r\n                hasDynamicKeys = true;\r\n                if (exp) {\r\n                    if (properties.length) {\r\n                        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n                        properties = [];\r\n                    }\r\n                    if (isBind) {\r\n                        mergeArgs.push(exp);\r\n                    }\r\n                    else {\r\n                        // v-on=\"obj\" -> toHandlers(obj)\r\n                        mergeArgs.push({\r\n                            type: 14 /* JS_CALL_EXPRESSION */,\r\n                            loc,\r\n                            callee: context.helper(TO_HANDLERS),\r\n                            arguments: [exp]\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    context.onError(createCompilerError(isBind\r\n                        ? 33 /* X_V_BIND_NO_EXPRESSION */\r\n                        : 34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n                }\r\n                continue;\r\n            }\r\n            const directiveTransform = context.directiveTransforms[name];\r\n            if (directiveTransform) {\r\n                // has built-in directive transform.\r\n                const { props, needRuntime } = directiveTransform(prop, node, context);\r\n                !ssr && props.forEach(analyzePatchFlag);\r\n                properties.push(...props);\r\n                if (needRuntime) {\r\n                    runtimeDirectives.push(prop);\r\n                    if (isSymbol(needRuntime)) {\r\n                        directiveImportMap.set(prop, needRuntime);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // no built-in transform, this is a user custom directive.\r\n                runtimeDirectives.push(prop);\r\n            }\r\n        }\r\n    }\r\n    let propsExpression = undefined;\r\n    // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\r\n    if (mergeArgs.length) {\r\n        if (properties.length) {\r\n            mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));\r\n        }\r\n        if (mergeArgs.length > 1) {\r\n            propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);\r\n        }\r\n        else {\r\n            // single v-bind with nothing else - no need for a mergeProps call\r\n            propsExpression = mergeArgs[0];\r\n        }\r\n    }\r\n    else if (properties.length) {\r\n        propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);\r\n    }\r\n    // patchFlag analysis\r\n    if (hasDynamicKeys) {\r\n        patchFlag |= 16 /* FULL_PROPS */;\r\n    }\r\n    else {\r\n        if (hasClassBinding) {\r\n            patchFlag |= 2 /* CLASS */;\r\n        }\r\n        if (hasStyleBinding) {\r\n            patchFlag |= 4 /* STYLE */;\r\n        }\r\n        if (dynamicPropNames.length) {\r\n            patchFlag |= 8 /* PROPS */;\r\n        }\r\n        if (hasHydrationEventBinding) {\r\n            patchFlag |= 32 /* HYDRATE_EVENTS */;\r\n        }\r\n    }\r\n    if ((patchFlag === 0 || patchFlag === 32 /* HYDRATE_EVENTS */) &&\r\n        (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {\r\n        patchFlag |= 512 /* NEED_PATCH */;\r\n    }\r\n    return {\r\n        props: propsExpression,\r\n        directives: runtimeDirectives,\r\n        patchFlag,\r\n        dynamicPropNames\r\n    };\r\n}\r\n// Dedupe props in an object literal.\r\n// Literal duplicated attributes would have been warned during the parse phase,\r\n// however, it's possible to encounter duplicated `onXXX` handlers with different\r\n// modifiers. We also need to merge static and dynamic class / style attributes.\r\n// - onXXX handlers / style: merge into array\r\n// - class: merge into single expression with concatenation\r\nfunction dedupeProperties(properties) {\r\n    const knownProps = new Map();\r\n    const deduped = [];\r\n    for (let i = 0; i < properties.length; i++) {\r\n        const prop = properties[i];\r\n        // dynamic keys are always allowed\r\n        if (prop.key.type === 8 /* COMPOUND_EXPRESSION */ || !prop.key.isStatic) {\r\n            deduped.push(prop);\r\n            continue;\r\n        }\r\n        const name = prop.key.content;\r\n        const existing = knownProps.get(name);\r\n        if (existing) {\r\n            if (name === 'style' || name === 'class' || name.startsWith('on')) {\r\n                mergeAsArray(existing, prop);\r\n            }\r\n            // unexpected duplicate, should have emitted error during parse\r\n        }\r\n        else {\r\n            knownProps.set(name, prop);\r\n            deduped.push(prop);\r\n        }\r\n    }\r\n    return deduped;\r\n}\r\nfunction mergeAsArray(existing, incoming) {\r\n    if (existing.value.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.value.elements.push(incoming.value);\r\n    }\r\n    else {\r\n        existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);\r\n    }\r\n}\r\nfunction buildDirectiveArgs(dir, context) {\r\n    const dirArgs = [];\r\n    const runtime = directiveImportMap.get(dir);\r\n    if (runtime) {\r\n        // built-in directive with runtime\r\n        dirArgs.push(context.helperString(runtime));\r\n    }\r\n    else {\r\n        {\r\n            // inject statement for resolving directive\r\n            context.helper(RESOLVE_DIRECTIVE);\r\n            context.directives.add(dir.name);\r\n            dirArgs.push(toValidAssetId(dir.name, `directive`));\r\n        }\r\n    }\r\n    const { loc } = dir;\r\n    if (dir.exp)\r\n        dirArgs.push(dir.exp);\r\n    if (dir.arg) {\r\n        if (!dir.exp) {\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        dirArgs.push(dir.arg);\r\n    }\r\n    if (Object.keys(dir.modifiers).length) {\r\n        if (!dir.arg) {\r\n            if (!dir.exp) {\r\n                dirArgs.push(`void 0`);\r\n            }\r\n            dirArgs.push(`void 0`);\r\n        }\r\n        const trueExpression = createSimpleExpression(`true`, false, loc);\r\n        dirArgs.push(createObjectExpression(dir.modifiers.map(modifier => createObjectProperty(modifier, trueExpression)), loc));\r\n    }\r\n    return createArrayExpression(dirArgs, dir.loc);\r\n}\r\nfunction stringifyDynamicPropNames(props) {\r\n    let propsNamesString = `[`;\r\n    for (let i = 0, l = props.length; i < l; i++) {\r\n        propsNamesString += JSON.stringify(props[i]);\r\n        if (i < l - 1)\r\n            propsNamesString += ', ';\r\n    }\r\n    return propsNamesString + `]`;\r\n}\r\nfunction isComponentTag(tag) {\r\n    return tag[0].toLowerCase() + tag.slice(1) === 'component';\r\n}\n\n(process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\n(process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\n\nconst transformSlotOutlet = (node, context) => {\r\n    if (isSlotOutlet(node)) {\r\n        const { children, loc } = node;\r\n        const { slotName, slotProps } = processSlotOutlet(node, context);\r\n        const slotArgs = [\r\n            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\r\n            slotName\r\n        ];\r\n        if (slotProps) {\r\n            slotArgs.push(slotProps);\r\n        }\r\n        if (children.length) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            slotArgs.push(createFunctionExpression([], children, false, false, loc));\r\n        }\r\n        if (context.scopeId && !context.slotted) {\r\n            if (!slotProps) {\r\n                slotArgs.push(`{}`);\r\n            }\r\n            if (!children.length) {\r\n                slotArgs.push(`undefined`);\r\n            }\r\n            slotArgs.push(`true`);\r\n        }\r\n        node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);\r\n    }\r\n};\r\nfunction processSlotOutlet(node, context) {\r\n    let slotName = `\"default\"`;\r\n    let slotProps = undefined;\r\n    const nonNameProps = [];\r\n    for (let i = 0; i < node.props.length; i++) {\r\n        const p = node.props[i];\r\n        if (p.type === 6 /* ATTRIBUTE */) {\r\n            if (p.value) {\r\n                if (p.name === 'name') {\r\n                    slotName = JSON.stringify(p.value.content);\r\n                }\r\n                else {\r\n                    p.name = camelize(p.name);\r\n                    nonNameProps.push(p);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (p.name === 'bind' && isBindKey(p.arg, 'name')) {\r\n                if (p.exp)\r\n                    slotName = p.exp;\r\n            }\r\n            else {\r\n                if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\r\n                    p.arg.content = camelize(p.arg.content);\r\n                }\r\n                nonNameProps.push(p);\r\n            }\r\n        }\r\n    }\r\n    if (nonNameProps.length > 0) {\r\n        const { props, directives } = buildProps(node, context, nonNameProps);\r\n        slotProps = props;\r\n        if (directives.length) {\r\n            context.onError(createCompilerError(35 /* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */, directives[0].loc));\r\n        }\r\n    }\r\n    return {\r\n        slotName,\r\n        slotProps\r\n    };\r\n}\n\nconst fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^\\s*function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nconst transformOn = (dir, node, context, augmentor) => {\r\n    const { loc, modifiers, arg } = dir;\r\n    if (!dir.exp && !modifiers.length) {\r\n        context.onError(createCompilerError(34 /* X_V_ON_NO_EXPRESSION */, loc));\r\n    }\r\n    let eventName;\r\n    if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n        if (arg.isStatic) {\r\n            const rawName = arg.content;\r\n            // for all event listeners, auto convert it to camelCase. See issue #2249\r\n            eventName = createSimpleExpression(toHandlerKey(camelize$1(rawName)), true, arg.loc);\r\n        }\r\n        else {\r\n            // #2388\r\n            eventName = createCompoundExpression([\r\n                `${context.helperString(TO_HANDLER_KEY)}(`,\r\n                arg,\r\n                `)`\r\n            ]);\r\n        }\r\n    }\r\n    else {\r\n        // already a compound expression.\r\n        eventName = arg;\r\n        eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);\r\n        eventName.children.push(`)`);\r\n    }\r\n    // handler processing\r\n    let exp = dir.exp;\r\n    if (exp && !exp.content.trim()) {\r\n        exp = undefined;\r\n    }\r\n    let shouldCache = context.cacheHandlers && !exp;\r\n    if (exp) {\r\n        const isMemberExp = isMemberExpression(exp.content);\r\n        const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));\r\n        const hasMultipleStatements = exp.content.includes(`;`);\r\n        if ((process.env.NODE_ENV !== 'production') && true) {\r\n            validateBrowserExpression(exp, context, false, hasMultipleStatements);\r\n        }\r\n        if (isInlineStatement || (shouldCache && isMemberExp)) {\r\n            // wrap inline statement in a function expression\r\n            exp = createCompoundExpression([\r\n                `${isInlineStatement\r\n                    ? `$event`\r\n                    : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,\r\n                exp,\r\n                hasMultipleStatements ? `}` : `)`\r\n            ]);\r\n        }\r\n    }\r\n    let ret = {\r\n        props: [\r\n            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))\r\n        ]\r\n    };\r\n    // apply extended compiler augmentor\r\n    if (augmentor) {\r\n        ret = augmentor(ret);\r\n    }\r\n    if (shouldCache) {\r\n        // cache handlers so that it's always the same handler being passed down.\r\n        // this avoids unnecessary re-renders when users use inline handlers on\r\n        // components.\r\n        ret.props[0].value = context.cache(ret.props[0].value);\r\n    }\r\n    return ret;\r\n};\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\r\n// codegen for the entire props object. This transform here is only for v-bind\r\n// *with* args.\r\nconst transformBind = (dir, node, context) => {\r\n    const { exp, modifiers, loc } = dir;\r\n    const arg = dir.arg;\r\n    if (arg.type !== 4 /* SIMPLE_EXPRESSION */) {\r\n        arg.children.unshift(`(`);\r\n        arg.children.push(`) || \"\"`);\r\n    }\r\n    else if (!arg.isStatic) {\r\n        arg.content = `${arg.content} || \"\"`;\r\n    }\r\n    // .prop is no longer necessary due to new patch behavior\r\n    // .sync is replaced by v-model:arg\r\n    if (modifiers.includes('camel')) {\r\n        if (arg.type === 4 /* SIMPLE_EXPRESSION */) {\r\n            if (arg.isStatic) {\r\n                arg.content = camelize$1(arg.content);\r\n            }\r\n            else {\r\n                arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;\r\n            }\r\n        }\r\n        else {\r\n            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);\r\n            arg.children.push(`)`);\r\n        }\r\n    }\r\n    if (!exp ||\r\n        (exp.type === 4 /* SIMPLE_EXPRESSION */ && !exp.content.trim())) {\r\n        context.onError(createCompilerError(33 /* X_V_BIND_NO_EXPRESSION */, loc));\r\n        return {\r\n            props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\r\n        };\r\n    }\r\n    return {\r\n        props: [createObjectProperty(arg, exp)]\r\n    };\r\n};\n\n// Merge adjacent text nodes and expressions into a single expression\r\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\r\nconst transformText = (node, context) => {\r\n    if (node.type === 0 /* ROOT */ ||\r\n        node.type === 1 /* ELEMENT */ ||\r\n        node.type === 11 /* FOR */ ||\r\n        node.type === 10 /* IF_BRANCH */) {\r\n        // perform the transform on node exit so that all expressions have already\r\n        // been processed.\r\n        return () => {\r\n            const children = node.children;\r\n            let currentContainer = undefined;\r\n            let hasText = false;\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child)) {\r\n                    hasText = true;\r\n                    for (let j = i + 1; j < children.length; j++) {\r\n                        const next = children[j];\r\n                        if (isText(next)) {\r\n                            if (!currentContainer) {\r\n                                currentContainer = children[i] = {\r\n                                    type: 8 /* COMPOUND_EXPRESSION */,\r\n                                    loc: child.loc,\r\n                                    children: [child]\r\n                                };\r\n                            }\r\n                            // merge adjacent text node into current\r\n                            currentContainer.children.push(` + `, next);\r\n                            children.splice(j, 1);\r\n                            j--;\r\n                        }\r\n                        else {\r\n                            currentContainer = undefined;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (!hasText ||\r\n                // if this is a plain element with a single text child, leave it\r\n                // as-is since the runtime has dedicated fast path for this by directly\r\n                // setting textContent of the element.\r\n                // for component root it's always normalized anyway.\r\n                (children.length === 1 &&\r\n                    (node.type === 0 /* ROOT */ ||\r\n                        (node.type === 1 /* ELEMENT */ &&\r\n                            node.tagType === 0 /* ELEMENT */)))) {\r\n                return;\r\n            }\r\n            // pre-convert text nodes into createTextVNode(text) calls to avoid\r\n            // runtime normalization.\r\n            for (let i = 0; i < children.length; i++) {\r\n                const child = children[i];\r\n                if (isText(child) || child.type === 8 /* COMPOUND_EXPRESSION */) {\r\n                    const callArgs = [];\r\n                    // createTextVNode defaults to single whitespace, so if it is a\r\n                    // single space the code could be an empty call to save bytes.\r\n                    if (child.type !== 2 /* TEXT */ || child.content !== ' ') {\r\n                        callArgs.push(child);\r\n                    }\r\n                    // mark dynamic text with flag so it gets patched inside a block\r\n                    if (!context.ssr &&\r\n                        getConstantType(child, context) === 0 /* NOT_CONSTANT */) {\r\n                        callArgs.push(1 /* TEXT */ +\r\n                            ((process.env.NODE_ENV !== 'production') ? ` /* ${PatchFlagNames[1 /* TEXT */]} */` : ``));\r\n                    }\r\n                    children[i] = {\r\n                        type: 12 /* TEXT_CALL */,\r\n                        content: child,\r\n                        loc: child.loc,\r\n                        codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)\r\n                    };\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\n\nconst seen = new WeakSet();\r\nconst transformOnce = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ && findDir(node, 'once', true)) {\r\n        if (seen.has(node)) {\r\n            return;\r\n        }\r\n        seen.add(node);\r\n        context.helper(SET_BLOCK_TRACKING);\r\n        return () => {\r\n            const cur = context.currentNode;\r\n            if (cur.codegenNode) {\r\n                cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */);\r\n            }\r\n        };\r\n    }\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const { exp, arg } = dir;\r\n    if (!exp) {\r\n        context.onError(createCompilerError(40 /* X_V_MODEL_NO_EXPRESSION */, dir.loc));\r\n        return createTransformProps();\r\n    }\r\n    const rawExp = exp.loc.source;\r\n    const expString = exp.type === 4 /* SIMPLE_EXPRESSION */ ? exp.content : rawExp;\r\n    // im SFC <script setup> inline mode, the exp may have been transformed into\r\n    // _unref(exp)\r\n    context.bindingMetadata[rawExp];\r\n    const maybeRef = !true    /* SETUP_CONST */;\r\n    if (!isMemberExpression(expString) && !maybeRef) {\r\n        context.onError(createCompilerError(41 /* X_V_MODEL_MALFORMED_EXPRESSION */, exp.loc));\r\n        return createTransformProps();\r\n    }\r\n    const propName = arg ? arg : createSimpleExpression('modelValue', true);\r\n    const eventName = arg\r\n        ? isStaticExp(arg)\r\n            ? `onUpdate:${arg.content}`\r\n            : createCompoundExpression(['\"onUpdate:\" + ', arg])\r\n        : `onUpdate:modelValue`;\r\n    let assignmentExp;\r\n    const eventArg = context.isTS ? `($event: any)` : `$event`;\r\n    {\r\n        assignmentExp = createCompoundExpression([\r\n            `${eventArg} => (`,\r\n            exp,\r\n            ` = $event)`\r\n        ]);\r\n    }\r\n    const props = [\r\n        // modelValue: foo\r\n        createObjectProperty(propName, dir.exp),\r\n        // \"onUpdate:modelValue\": $event => (foo = $event)\r\n        createObjectProperty(eventName, assignmentExp)\r\n    ];\r\n    // modelModifiers: { foo: true, \"bar-baz\": true }\r\n    if (dir.modifiers.length && node.tagType === 1 /* COMPONENT */) {\r\n        const modifiers = dir.modifiers\r\n            .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\r\n            .join(`, `);\r\n        const modifiersKey = arg\r\n            ? isStaticExp(arg)\r\n                ? `${arg.content}Modifiers`\r\n                : createCompoundExpression([arg, ' + \"Modifiers\"'])\r\n            : `modelModifiers`;\r\n        props.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2 /* CAN_HOIST */)));\r\n    }\r\n    return createTransformProps(props);\r\n};\r\nfunction createTransformProps(props = []) {\r\n    return { props };\r\n}\n\nfunction getBaseTransformPreset(prefixIdentifiers) {\r\n    return [\r\n        [\r\n            transformOnce,\r\n            transformIf,\r\n            transformFor,\r\n            ...((process.env.NODE_ENV !== 'production')\r\n                    ? [transformExpression]\r\n                    : []),\r\n            transformSlotOutlet,\r\n            transformElement,\r\n            trackSlotScopes,\r\n            transformText\r\n        ],\r\n        {\r\n            on: transformOn,\r\n            bind: transformBind,\r\n            model: transformModel\r\n        }\r\n    ];\r\n}\r\n// we name it `baseCompile` so that higher order compilers like\r\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\r\nfunction baseCompile(template, options = {}) {\r\n    const onError = options.onError || defaultOnError;\r\n    const isModuleMode = options.mode === 'module';\r\n    /* istanbul ignore if */\r\n    {\r\n        if (options.prefixIdentifiers === true) {\r\n            onError(createCompilerError(45 /* X_PREFIX_ID_NOT_SUPPORTED */));\r\n        }\r\n        else if (isModuleMode) {\r\n            onError(createCompilerError(46 /* X_MODULE_MODE_NOT_SUPPORTED */));\r\n        }\r\n    }\r\n    const prefixIdentifiers = !true ;\r\n    if (options.cacheHandlers) {\r\n        onError(createCompilerError(47 /* X_CACHE_HANDLER_NOT_SUPPORTED */));\r\n    }\r\n    if (options.scopeId && !isModuleMode) {\r\n        onError(createCompilerError(48 /* X_SCOPE_ID_NOT_SUPPORTED */));\r\n    }\r\n    const ast = isString(template) ? baseParse(template, options) : template;\r\n    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();\r\n    transform(ast, extend({}, options, {\r\n        prefixIdentifiers,\r\n        nodeTransforms: [\r\n            ...nodeTransforms,\r\n            ...(options.nodeTransforms || []) // user transforms\r\n        ],\r\n        directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {} // user transforms\r\n        )\r\n    }));\r\n    return generate(ast, extend({}, options, {\r\n        prefixIdentifiers\r\n    }));\r\n}\n\nconst noopDirectiveTransform = () => ({ props: [] });\n\nexport { BASE_TRANSITION, CAMELIZE, CAPITALIZE, CREATE_BLOCK, CREATE_COMMENT, CREATE_SLOTS, CREATE_STATIC, CREATE_TEXT, CREATE_VNODE, FRAGMENT, IS_REF, KEEP_ALIVE, MERGE_PROPS, OPEN_BLOCK, POP_SCOPE_ID, PUSH_SCOPE_ID, RENDER_LIST, RENDER_SLOT, RESOLVE_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_DYNAMIC_COMPONENT, SET_BLOCK_TRACKING, SUSPENSE, TELEPORT, TO_DISPLAY_STRING, TO_HANDLERS, TO_HANDLER_KEY, UNREF, WITH_CTX, WITH_DIRECTIVES, WITH_SCOPE_ID, advancePositionWithClone, advancePositionWithMutation, assert, baseCompile, baseParse, buildProps, buildSlots, createArrayExpression, createAssignmentExpression, createBlockStatement, createCacheExpression, createCallExpression, createCompilerError, createCompoundExpression, createConditionalExpression, createForLoopParams, createFunctionExpression, createIfStatement, createInterpolation, createObjectExpression, createObjectProperty, createReturnStatement, createRoot, createSequenceExpression, createSimpleExpression, createStructuralDirectiveTransform, createTemplateLiteral, createTransformContext, createVNodeCall, findDir, findProp, generate, getBaseTransformPreset, getInnerRange, hasDynamicKeyVBind, hasScopeRef, helperNameMap, injectProp, isBindKey, isBuiltInType, isCoreComponent, isMemberExpression, isSimpleIdentifier, isSlotOutlet, isStaticExp, isTemplateNode, isText, isVSlot, locStub, noopDirectiveTransform, processExpression, processFor, processIf, processSlotOutlet, registerRuntimeHelpers, resolveComponentType, toValidAssetId, trackSlotScopes, trackVForSlotScopes, transform, transformBind, transformElement, transformExpression, transformModel, transformOn, traverseNode };\n","import { registerRuntimeHelpers, isBuiltInType, createSimpleExpression, createCompilerError, createObjectProperty, createCallExpression, TO_DISPLAY_STRING, transformModel as transformModel$1, findProp, hasDynamicKeyVBind, transformOn as transformOn$1, createCompoundExpression, isStaticExp, noopDirectiveTransform, baseCompile, baseParse } from '@vue/compiler-core';\nexport * from '@vue/compiler-core';\nimport { isVoidTag, isHTMLTag, isSVGTag, makeMap, parseStringStyle, capitalize, extend } from '@vue/shared';\n\nconst V_MODEL_RADIO = Symbol((process.env.NODE_ENV !== 'production') ? `vModelRadio` : ``);\r\nconst V_MODEL_CHECKBOX = Symbol((process.env.NODE_ENV !== 'production') ? `vModelCheckbox` : ``);\r\nconst V_MODEL_TEXT = Symbol((process.env.NODE_ENV !== 'production') ? `vModelText` : ``);\r\nconst V_MODEL_SELECT = Symbol((process.env.NODE_ENV !== 'production') ? `vModelSelect` : ``);\r\nconst V_MODEL_DYNAMIC = Symbol((process.env.NODE_ENV !== 'production') ? `vModelDynamic` : ``);\r\nconst V_ON_WITH_MODIFIERS = Symbol((process.env.NODE_ENV !== 'production') ? `vOnModifiersGuard` : ``);\r\nconst V_ON_WITH_KEYS = Symbol((process.env.NODE_ENV !== 'production') ? `vOnKeysGuard` : ``);\r\nconst V_SHOW = Symbol((process.env.NODE_ENV !== 'production') ? `vShow` : ``);\r\nconst TRANSITION = Symbol((process.env.NODE_ENV !== 'production') ? `Transition` : ``);\r\nconst TRANSITION_GROUP = Symbol((process.env.NODE_ENV !== 'production') ? `TransitionGroup` : ``);\r\nregisterRuntimeHelpers({\r\n    [V_MODEL_RADIO]: `vModelRadio`,\r\n    [V_MODEL_CHECKBOX]: `vModelCheckbox`,\r\n    [V_MODEL_TEXT]: `vModelText`,\r\n    [V_MODEL_SELECT]: `vModelSelect`,\r\n    [V_MODEL_DYNAMIC]: `vModelDynamic`,\r\n    [V_ON_WITH_MODIFIERS]: `withModifiers`,\r\n    [V_ON_WITH_KEYS]: `withKeys`,\r\n    [V_SHOW]: `vShow`,\r\n    [TRANSITION]: `Transition`,\r\n    [TRANSITION_GROUP]: `TransitionGroup`\r\n});\n\n/* eslint-disable no-restricted-globals */\r\nlet decoder;\r\nfunction decodeHtmlBrowser(raw) {\r\n    (decoder || (decoder = document.createElement('div'))).innerHTML = raw;\r\n    return decoder.textContent;\r\n}\n\nconst isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);\r\nconst parserOptions = {\r\n    isVoidTag,\r\n    isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\r\n    isPreTag: tag => tag === 'pre',\r\n    decodeEntities: decodeHtmlBrowser ,\r\n    isBuiltInComponent: (tag) => {\r\n        if (isBuiltInType(tag, `Transition`)) {\r\n            return TRANSITION;\r\n        }\r\n        else if (isBuiltInType(tag, `TransitionGroup`)) {\r\n            return TRANSITION_GROUP;\r\n        }\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\r\n    getNamespace(tag, parent) {\r\n        let ns = parent ? parent.ns : 0 /* HTML */;\r\n        if (parent && ns === 2 /* MATH_ML */) {\r\n            if (parent.tag === 'annotation-xml') {\r\n                if (tag === 'svg') {\r\n                    return 1 /* SVG */;\r\n                }\r\n                if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&\r\n                    a.name === 'encoding' &&\r\n                    a.value != null &&\r\n                    (a.value.content === 'text/html' ||\r\n                        a.value.content === 'application/xhtml+xml'))) {\r\n                    ns = 0 /* HTML */;\r\n                }\r\n            }\r\n            else if (/^m(?:[ions]|text)$/.test(parent.tag) &&\r\n                tag !== 'mglyph' &&\r\n                tag !== 'malignmark') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        else if (parent && ns === 1 /* SVG */) {\r\n            if (parent.tag === 'foreignObject' ||\r\n                parent.tag === 'desc' ||\r\n                parent.tag === 'title') {\r\n                ns = 0 /* HTML */;\r\n            }\r\n        }\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === 'svg') {\r\n                return 1 /* SVG */;\r\n            }\r\n            if (tag === 'math') {\r\n                return 2 /* MATH_ML */;\r\n            }\r\n        }\r\n        return ns;\r\n    },\r\n    // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\r\n    getTextMode({ tag, ns }) {\r\n        if (ns === 0 /* HTML */) {\r\n            if (tag === 'textarea' || tag === 'title') {\r\n                return 1 /* RCDATA */;\r\n            }\r\n            if (isRawTextContainer(tag)) {\r\n                return 2 /* RAWTEXT */;\r\n            }\r\n        }\r\n        return 0 /* DATA */;\r\n    }\r\n};\n\n// Parse inline CSS strings for static style attributes into an object.\r\n// This is a NodeTransform since it works on the static `style` attribute and\r\n// converts it into a dynamic equivalent:\r\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\r\n// It is then processed by `transformElement` and included in the generated\r\n// props.\r\nconst transformStyle = node => {\r\n    if (node.type === 1 /* ELEMENT */) {\r\n        node.props.forEach((p, i) => {\r\n            if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {\r\n                // replace p with an expression node\r\n                node.props[i] = {\r\n                    type: 7 /* DIRECTIVE */,\r\n                    name: `bind`,\r\n                    arg: createSimpleExpression(`style`, true, p.loc),\r\n                    exp: parseInlineCSS(p.value.content, p.loc),\r\n                    modifiers: [],\r\n                    loc: p.loc\r\n                };\r\n            }\r\n        });\r\n    }\r\n};\r\nconst parseInlineCSS = (cssText, loc) => {\r\n    const normalized = parseStringStyle(cssText);\r\n    return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);\r\n};\n\nfunction createDOMCompilerError(code, loc) {\r\n    return createCompilerError(code, loc, (process.env.NODE_ENV !== 'production') || !true ? DOMErrorMessages : undefined);\r\n}\r\nconst DOMErrorMessages = {\r\n    [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,\r\n    [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,\r\n    [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,\r\n    [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,\r\n    [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\r\n    [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,\r\n    [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\r\n    [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\r\n    [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,\r\n    [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,\r\n    [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\r\n};\n\nconst transformVHtml = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))\r\n        ]\r\n    };\r\n};\n\nconst transformVText = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));\r\n    }\r\n    if (node.children.length) {\r\n        context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));\r\n        node.children.length = 0;\r\n    }\r\n    return {\r\n        props: [\r\n            createObjectProperty(createSimpleExpression(`textContent`, true), exp\r\n                ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)\r\n                : createSimpleExpression('', true))\r\n        ]\r\n    };\r\n};\n\nconst transformModel = (dir, node, context) => {\r\n    const baseResult = transformModel$1(dir, node, context);\r\n    // base transform has errors OR component v-model (only need props)\r\n    if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {\r\n        return baseResult;\r\n    }\r\n    if (dir.arg) {\r\n        context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));\r\n    }\r\n    function checkDuplicatedValue() {\r\n        const value = findProp(node, 'value');\r\n        if (value) {\r\n            context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\r\n        }\r\n    }\r\n    const { tag } = node;\r\n    const isCustomElement = context.isCustomElement(tag);\r\n    if (tag === 'input' ||\r\n        tag === 'textarea' ||\r\n        tag === 'select' ||\r\n        isCustomElement) {\r\n        let directiveToUse = V_MODEL_TEXT;\r\n        let isInvalidType = false;\r\n        if (tag === 'input' || isCustomElement) {\r\n            const type = findProp(node, `type`);\r\n            if (type) {\r\n                if (type.type === 7 /* DIRECTIVE */) {\r\n                    // :type=\"foo\"\r\n                    directiveToUse = V_MODEL_DYNAMIC;\r\n                }\r\n                else if (type.value) {\r\n                    switch (type.value.content) {\r\n                        case 'radio':\r\n                            directiveToUse = V_MODEL_RADIO;\r\n                            break;\r\n                        case 'checkbox':\r\n                            directiveToUse = V_MODEL_CHECKBOX;\r\n                            break;\r\n                        case 'file':\r\n                            isInvalidType = true;\r\n                            context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                            break;\r\n                        default:\r\n                            // text type\r\n                            (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else if (hasDynamicKeyVBind(node)) {\r\n                // element has bindings with dynamic keys, which can possibly contain\r\n                // \"type\".\r\n                directiveToUse = V_MODEL_DYNAMIC;\r\n            }\r\n            else {\r\n                // text type\r\n                (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();\r\n            }\r\n        }\r\n        else if (tag === 'select') {\r\n            directiveToUse = V_MODEL_SELECT;\r\n        }\r\n        else {\r\n            // textarea\r\n            (process.env.NODE_ENV !== 'production') && checkDuplicatedValue();\r\n        }\r\n        // inject runtime directive\r\n        // by returning the helper symbol via needRuntime\r\n        // the import will replaced a resolveDirective call.\r\n        if (!isInvalidType) {\r\n            baseResult.needRuntime = context.helper(directiveToUse);\r\n        }\r\n    }\r\n    else {\r\n        context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n    }\r\n    // native vmodel doesn't need the `modelValue` props since they are also\r\n    // passed to the runtime as `binding.value`. removing it reduces code size.\r\n    baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&\r\n        p.key.content === 'modelValue'));\r\n    return baseResult;\r\n};\n\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);\r\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\r\n// event propagation management\r\n`stop,prevent,self,` +\r\n    // system modifiers + exact\r\n    `ctrl,shift,alt,meta,exact,` +\r\n    // mouse\r\n    `middle`);\r\n// left & right could be mouse or key modifiers based on event type\r\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');\r\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);\r\nconst resolveModifiers = (key, modifiers) => {\r\n    const keyModifiers = [];\r\n    const nonKeyModifiers = [];\r\n    const eventOptionModifiers = [];\r\n    for (let i = 0; i < modifiers.length; i++) {\r\n        const modifier = modifiers[i];\r\n        if (isEventOptionModifier(modifier)) {\r\n            // eventOptionModifiers: modifiers for addEventListener() options,\r\n            // e.g. .passive & .capture\r\n            eventOptionModifiers.push(modifier);\r\n        }\r\n        else {\r\n            // runtimeModifiers: modifiers that needs runtime guards\r\n            if (maybeKeyModifier(modifier)) {\r\n                if (isStaticExp(key)) {\r\n                    if (isKeyboardEvent(key.content)) {\r\n                        keyModifiers.push(modifier);\r\n                    }\r\n                    else {\r\n                        nonKeyModifiers.push(modifier);\r\n                    }\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n            }\r\n            else {\r\n                if (isNonKeyModifier(modifier)) {\r\n                    nonKeyModifiers.push(modifier);\r\n                }\r\n                else {\r\n                    keyModifiers.push(modifier);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        keyModifiers,\r\n        nonKeyModifiers,\r\n        eventOptionModifiers\r\n    };\r\n};\r\nconst transformClick = (key, event) => {\r\n    const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';\r\n    return isStaticClick\r\n        ? createSimpleExpression(event, true)\r\n        : key.type !== 4 /* SIMPLE_EXPRESSION */\r\n            ? createCompoundExpression([\r\n                `(`,\r\n                key,\r\n                `) === \"onClick\" ? \"${event}\" : (`,\r\n                key,\r\n                `)`\r\n            ])\r\n            : key;\r\n};\r\nconst transformOn = (dir, node, context) => {\r\n    return transformOn$1(dir, node, context, baseResult => {\r\n        const { modifiers } = dir;\r\n        if (!modifiers.length)\r\n            return baseResult;\r\n        let { key, value: handlerExp } = baseResult.props[0];\r\n        const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers);\r\n        // normalize click.right and click.middle since they don't actually fire\r\n        if (nonKeyModifiers.includes('right')) {\r\n            key = transformClick(key, `onContextmenu`);\r\n        }\r\n        if (nonKeyModifiers.includes('middle')) {\r\n            key = transformClick(key, `onMouseup`);\r\n        }\r\n        if (nonKeyModifiers.length) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\r\n                handlerExp,\r\n                JSON.stringify(nonKeyModifiers)\r\n            ]);\r\n        }\r\n        if (keyModifiers.length &&\r\n            // if event name is dynamic, always wrap with keys guard\r\n            (!isStaticExp(key) || isKeyboardEvent(key.content))) {\r\n            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\r\n                handlerExp,\r\n                JSON.stringify(keyModifiers)\r\n            ]);\r\n        }\r\n        if (eventOptionModifiers.length) {\r\n            const modifierPostfix = eventOptionModifiers.map(capitalize).join('');\r\n            key = isStaticExp(key)\r\n                ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\r\n                : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`]);\r\n        }\r\n        return {\r\n            props: [createObjectProperty(key, handlerExp)]\r\n        };\r\n    });\r\n};\n\nconst transformShow = (dir, node, context) => {\r\n    const { exp, loc } = dir;\r\n    if (!exp) {\r\n        context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));\r\n    }\r\n    return {\r\n        props: [],\r\n        needRuntime: context.helper(V_SHOW)\r\n    };\r\n};\n\nconst warnTransitionChildren = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 1 /* COMPONENT */) {\r\n        const component = context.isBuiltInComponent(node.tag);\r\n        if (component === TRANSITION) {\r\n            return () => {\r\n                if (node.children.length && hasMultipleChildren(node)) {\r\n                    context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {\r\n                        start: node.children[0].loc.start,\r\n                        end: node.children[node.children.length - 1].loc.end,\r\n                        source: ''\r\n                    }));\r\n                }\r\n            };\r\n        }\r\n    }\r\n};\r\nfunction hasMultipleChildren(node) {\r\n    // #1352 filter out potential comment nodes.\r\n    const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));\r\n    const child = children[0];\r\n    return (children.length !== 1 ||\r\n        child.type === 11 /* FOR */ ||\r\n        (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));\r\n}\n\nconst ignoreSideEffectTags = (node, context) => {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 0 /* ELEMENT */ &&\r\n        (node.tag === 'script' || node.tag === 'style')) {\r\n        context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));\r\n        context.removeNode();\r\n    }\r\n};\n\nconst DOMNodeTransforms = [\r\n    transformStyle,\r\n    ...((process.env.NODE_ENV !== 'production') ? [warnTransitionChildren] : [])\r\n];\r\nconst DOMDirectiveTransforms = {\r\n    cloak: noopDirectiveTransform,\r\n    html: transformVHtml,\r\n    text: transformVText,\r\n    model: transformModel,\r\n    on: transformOn,\r\n    show: transformShow\r\n};\r\nfunction compile(template, options = {}) {\r\n    return baseCompile(template, extend({}, parserOptions, options, {\r\n        nodeTransforms: [\r\n            // ignore <script> and <tag>\r\n            // this is not put inside DOMNodeTransforms because that list is used\r\n            // by compiler-ssr to generate vnode fallback branches\r\n            ignoreSideEffectTags,\r\n            ...DOMNodeTransforms,\r\n            ...(options.nodeTransforms || [])\r\n        ],\r\n        directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\r\n        transformHoist: null \r\n    }));\r\n}\r\nfunction parse(template, options = {}) {\r\n    return baseParse(template, extend({}, parserOptions, options));\r\n}\n\nexport { DOMDirectiveTransforms, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };\n"],"sourceRoot":""}